{
  "success": true,
  "data": [
    {
      "id": "5cbfd9aca86ae80ce64b3175",
      "author_id": "4f447c2f0a8abae26e01b27d",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href=\"https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f\">https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f</a>\n语雀地址：<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href=\"https://github.com/nodejs/Release\">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class=\"prettyprint language-bash\"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/63403762\">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/v8-release-72#async-stack-traces\">异步堆栈跟踪</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch\">参数调用不匹配时的调用速度优化</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-73#faster-await\">更快的 await</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-72#javascript-parsing\">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href=\"https://github.com/tc39/proposal-class-fields\">Private Class Fields</a> 也能用了：</p>\n<pre class=\"prettyprint language-javascript\"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href=\"https://github.com/nodejs/llhttp\">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href=\"https://v8.dev/blog/code-caching\">v8 code cache</a> 的支持，<a href=\"https://github.com/nodejs/node/pull/27161\">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href=\"https://github.com/nodejs/node/pull/24950\">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href=\"https://nodejs.org/api/worker_threads.html\">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：<a href=\"https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6\">https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6</a></p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href=\"https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/27133\">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/26501\">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href=\"https://medium.com/@nodejs/announcing-a-new-experimental-modules-1be8d2d6c2ff\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href=\"https://nodejs.org/api/n-api.html#n_api_n_api\">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href=\"https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4\">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href=\"https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/\">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href=\"https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list\">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class=\"prettyprint language-bash\"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>",
      "title": "Node 12 值得关注的新特性",
      "last_reply_at": "2019-07-12T04:34:56.342Z",
      "good": false,
      "top": true,
      "reply_count": 53,
      "visit_count": 71973,
      "create_at": "2019-04-24T03:36:12.582Z",
      "author": {
        "loginname": "atian25",
        "avatar_url": "https://avatars2.githubusercontent.com/u/227713?v=4&s=120"
      }
    },
    {
      "id": "5bd4772a14e994202cd5bdb7",
      "author_id": "504c28a2e2b845157708cb61",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>",
      "title": "服务器迁移至 aws 日本机房",
      "last_reply_at": "2019-07-12T02:24:33.508Z",
      "good": false,
      "top": true,
      "reply_count": 200,
      "visit_count": 84139,
      "create_at": "2018-10-27T14:33:14.694Z",
      "author": {
        "loginname": "alsotang",
        "avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
      }
    },
    {
      "id": "5d39823d9969a529571d72da",
      "author_id": "5d3980dd9969a529571d72c9",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>blog.js</p>\n<pre class=\"prettyprint language-nodejs\"><code>const mongoose = require(&#x27;mongoose&#x27;)\n\nconst Schema = mongoose.Schema\nconst Category = require(&#x27;.&#x2F;category&#x27;)\nconst User = require(&#x27;.&#x2F;user&#x27;)\n\n\n&#x2F;&#x2F; 从comment.js引入Comment==========================\nconst Comment = require(&#x27;.&#x2F;comment&#x27;)\n\n\nconst blogSchema = new Schema({\n    category: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: Category\n    },\n    title: {\n        type: String,\n        require: true\n    },\n    desc: {\n        type: String,\n        require: true\n    },\n    content: {\n        type: String,\n        require: true\n    },\n    add_time: {\n        type: Date,\n        default: new Date()\n    },\n    author: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: User\n    },\n    view_count: {\n        type: Number,\n        default: 0\n    },\n    comment: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: Comment\n    }\n})\n\nmodule.exports = Blog = mongoose.model(&#x27;blogs&#x27;, blogSchema)\n</code></pre><p>comment.js</p>\n<pre class=\"prettyprint language-nodejs\"><code>const mongoose = require(&#x27;mongoose&#x27;)\n\n&#x2F;&#x2F; 从blog.js引入Blog===============================\nconst Blog = require(&#x27;.&#x2F;blog&#x27;)\nconst User = require(&#x27;.&#x2F;user&#x27;)\n\nconst commentSchema = new mongoose.Schema({\n    blog: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: Blog\n    },\n    content: {\n        type: String,\n        require: true\n    },\n    add_time: {\n        type: Date,\n        default: Date.now\n    },\n    author: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: User\n    }\n})\n\n\nmodule.exports = Comment = mongoose.model(&#x27;comments&#x27;, commentSchema)\n</code></pre><p>报错信息：Invalid ref at path “blog”. Got {}</p>\n</div>",
      "title": "nodejs模块循环引入的问题",
      "last_reply_at": "2019-07-27T05:19:43.614Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 757,
      "create_at": "2019-07-25T10:19:41.464Z",
      "author": {
        "loginname": "123123hgj",
        "avatar_url": "https://avatars0.githubusercontent.com/u/43122596?v=4&s=120"
      }
    },
    {
      "id": "5d3bdd3cb4725a628e269109",
      "author_id": "5307b7865a67a3aa09249b26",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>系列文章：</p>\n<ul>\n<li><a href=\"https://f-e-d.club/topic/using-certbot-deployment-let-s-encrypt-free-ssl-certificate-implementation-https.article\">《使用 Certbot 部署 Let’s Encrypt 免费 SSL 证书实现 HTTPS》</a></li>\n<li><a href=\"https://f-e-d.club/topic/use-acme-sh-deployment-let-s-encrypt-by-ali-cloud-dns-generic-domain-https-authentication.article\">《使用 acme.sh 部署 Let’s Encrypt 通过阿里云 DNS 验证方式实现泛域名 HTTPS》</a></li>\n</ul>\n<p>本篇是第三种方法来进行 Let’s Encrypt 证书定时签署。</p>\n<h1>介绍 elev</h1>\n<p><a href=\"https://clis.ydr.me/bin/elev\">elev 官网</a>。</p>\n<p>elev 是 Easy Let’s Encrypt Visa（简洁的 Let’s Encrypt 签证）的首字母。</p>\n<p>elev 是基于开源模块而进行封装的 nodejs 命令行工具，主要实现 Let’s Encrypt 的 泛域名 DNS 记录验证方式（目前仅支持阿里云 DNS 服务商）的 SSL 证书的签发和自动续期。</p>\n<h1>安装 elev</h1>\n<p>因为 elev 是 Node.js 全局命令，因此使用 npm 安装即可。</p>\n<pre class=\"prettyprint language-bash\"><code>npm install elev --global\n</code></pre><h1>入门 elev</h1>\n<pre class=\"prettyprint language-bash\"><code>➜  ~ elev\n\n  &#96;7MM&quot;&quot;&quot;YMM  &#96;7MMF&#x27;      &#96;7MM&quot;&quot;&quot;YMM  &#96;7MMF&#x27;   &#96;7MF&#x27;\n    MM    &#96;7    MM          MM    &#96;7    &#96;MA     ,V\n    MM   d      MM          MM   d       VM:   ,V\n    MMmmMM      MM          MMmmMM        MM.  M&#x27;\n    MM   Y  ,   MM      ,   MM   Y  ,     &#96;MM A&#x27;\n    MM     ,M   MM     ,M   MM     ,M      :MM;\n  .JMMmmmmMMM .JMMmmmmMMM .JMMmmmmMMM       VF\n\n  Usages:\n  elev domain                     列出当前已配置的域名\n  elev domain &lt;domain&gt;            新建或编辑域名配置文件\n  elev domain &lt;domain&gt; -r &lt;reference&gt;\n                                  参考指定域名进行新建或编辑配置文件\n  elev worker &lt;ID&gt;                查看指定 ID 的工作记录\n\n  Commands:\n  domain                          域名配置相关\n  visa                            签发一张 Let’s Encrypt 泛域名证书\n  cron                            定时任务相关\n  schedule                        定时计划相关\n  worker                          定时任务工作\n  smtp                            SMTP 相关\n  version                         输出版本号并检查更新\n\n  Options:\n  --version, -v, -V               print version information\n  --help, -h, -H                  print help information\n</code></pre><p>原文看这里 <a href=\"https://f-e-d.club/topic/using-elev-timing-deployment-let's-encrypt-by-ali-cloud-dns-generic-domain-https-ssl-certificate-verification.article\">https://f-e-d.club/topic/using-elev-timing-deployment-let’s-encrypt-by-ali-cloud-dns-generic-domain-https-ssl-certificate-verification.article</a></p>\n</div>",
      "title": "使用 elev 定时部署 Let's Encrypt 通过阿里云 DNS 验证方式实现泛域名 HTTPS/SSL 证书",
      "last_reply_at": "2019-07-27T05:12:28.862Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 170,
      "create_at": "2019-07-27T05:12:28.862Z",
      "author": {
        "loginname": "cloudcome",
        "avatar_url": "https://avatars0.githubusercontent.com/u/3362033?v=4&s=120"
      }
    },
    {
      "id": "5746cdcf991011691ef17b88",
      "author_id": "57329f1c2e11c7a80c33f87a",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>express作为nodejs平台下非常流行的web框架，相信大家都对其已经很熟悉了，对于express的使用这里不再多说，如有需要可以移步到<a href>www.expressjs.com</a>自行查看express的官方文档，今天主要是想说下express的路由机制。</p>\n<p>最近抽时间看了下express的源码，看完源码体会最深刻的还是express的路由机制，感觉搞懂了express的路由就算是基本搞懂了express，而express的路由机制都是router模块来实现，所以在这里对express的router模块实现进行一下简单的整理，所有理解都来自自己对源码的理解，如有不对的地方，还请各位多多拍砖。</p>\n<p>好了，废话不多说了，进入正题，首先先了解一下express源码的目录结构，如下图：\n<img src=\"//static.cnodejs.org/FnuptVMv5TZchESOT0JRT0re7KZ0\" alt=\"express.jpg\">\napplication.js为express的主文件，express.js对application.js进行了包装，对外提供各种API，这里我们不多做说明，我们今天要说的就是router目录下的内容，express关于路由的具体实现都是由这个目录完成。我们先看一个简单的express路由的例子：</p>\n<pre class=\"prettyprint\"><code>var app = express();\napp.get(&#x27;&#x2F;hello&#x27;, function(req,res){\n    res.send(&#x27;hello everyone!!!&#x27;); \n}); \n</code></pre><p>上边就是一个最简单的express路由的例子，将path为 ‘/hello’ 的请求路由到当前的处理函数，并返回 ‘hello everyone!!!’ ，那么我们来一起看看，app.get()何实现的，通过查看代码我们发现源码里并没有app.get()的实现，但仔细找找你会在application.js中发现如下的代码：</p>\n<pre class=\"prettyprint\"><code>methods.forEach(function(method){\n  app[method] = function(path){\n    if (method === &#x27;get&#x27; &amp;&amp; arguments.length === 1) {\n      &#x2F;&#x2F; app.get(setting)\n      return this.set(path);\n    }\n\n    this.lazyrouter();\n\n    var route = this._router.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n</code></pre><p>(⊙o⊙)哦，隐藏的好深，原来express对get，post等方法的添加都是动态的，methods来自<a href=\"https://www.npmjs.com/package/methods\">methods</a>这个模块，他提供了和nodejs  http.METHODS 相似的东西，返回了http协议的所有method，这样一个循环搞定了所有method函数的定义，赞一个。</p>\n<p>接下来我们主要分析下函数内部的实现，首先判断如果method等于get，并且参数的长度是1，则直接返回this.set(path)，大家查看express官网的API就可以发现，app.get()函数其实实现了两种功能，如果参数长度是1，则返回app.set()定义的变量，如果参数长度大于1，则进行路由处理。</p>\n<p>继续往下看，<strong>this.lazyrouter()</strong>，从名字来看，好像是懒加载router，那我们看看源码：</p>\n<pre class=\"prettyprint\"><code>app.lazyrouter = function lazyrouter() {\n  if (!this._router) {\n    this._router = new Router({\n      caseSensitive: this.enabled(&#x27;case sensitive routing&#x27;),\n      strict: this.enabled(&#x27;strict routing&#x27;)\n    });\n\n    this._router.use(query(this.get(&#x27;query parser fn&#x27;)));\n    this._router.use(middleware.init(this));\n  }\n};\n</code></pre><p>果然是，如果_router不存在，就new一个Router出来，而这个Router就是我们刚才在目录结构中看到的router目录，也就是今天的主角Router模块。继续上边的代码，加载完_router之后，执行了**this._router.route(path)**这样一行代码，那这行代码有做了什么呢，我们再继续往下挖，我们在router目录下的index.js中找到了它的实现：</p>\n<pre class=\"prettyprint\"><code>proto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n</code></pre><p>我们可以看到，这里new了一个Route对象，并且new了一个Layer对象，然后将Route对象赋值给layer.route，最后将这个Layer添加到stack数组中。在这里我们先不对Layer进行说明，后边会有专门的介绍，我们先来看看Route，那这个Route又是什么呢，它和Router模块有什么关系呢，我来说下我的理解：</p>\n<blockquote>\n<p>Route模块对应的是route.js，主要是来处理路由信息的，每条路由都会生成一个Route实例。而Router模块对应的是index.js，Router是一个路由的集合，在Router模块下可以定义多个路由，也就是说，一个Router模块会包含多个Route模块。通过上边的代码我们已经知道，每个express创建的实例都会懒加载一个_router来进行路由处理，这个_router就是一个Router模块。</p>\n</blockquote>\n<p>理解了Route和Router的关系，感觉一下子清爽了有木有，O(∩_∩)O哈哈~~~</p>\n<p>好了，我们接着看代码，拿到route对象之后，通过apply的方式调用了route的对应method函数，假如我们现在使用的是get函数，那现在method就等于get。看到这里大家就会发现，express实例在处理路由的时候，会先创建一个Router对象，然后用Router对象和对应的path来生成一个Route对象，最后由Route对象来处理具体的路由实现。</p>\n<p>好了，那接下来我们继续深入研究，看看route.method究竟做了什么，我们找到route.js文件，发现如下的代码：</p>\n<pre class=\"prettyprint\"><code>methods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i &lt; handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== &#x27;function&#x27;) {\n        var type = toString.call(handle);\n        var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;\n        throw new Error(msg);\n      }\n\n      debug(&#x27;%s %s&#x27;, method, this.path);\n\n      var layer = Layer(&#x27;&#x2F;&#x27;, {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n</code></pre><p>啊啊啊，原来route和application运用了同样的技巧，通过循环methods来动态添加method函数，我们直接看函数内部实现，首先通过入参获取到handles，这里的handles就是我们定义的路由中间件函数，这里我们可以看到是一个数组，所以我们可以给一个路由添加多个中间件函数。接下来循环handles，在每个循环中利用handle来创建一个Layer对象，然后将Layer对象push到stack中去，这个stack其实是Route内部维护的一个数组，用来存放所有的Layer对象。现在你一定想这道这个Layer到底是什么东西，那我们继续往下看，看看layer.js的源代码：</p>\n<pre class=\"prettyprint\"><code>function Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n\n  debug(&#x27;new %s&#x27;, path);\n  var opts = options || {};\n\n  this.handle = fn;\n  this.name = fn.name || &#x27;&lt;anonymous&gt;&#x27;;\n  this.params = undefined;\n  this.path = undefined;\n  this.regexp = pathRegexp(path, this.keys = [], opts);\n\n  if (path === &#x27;&#x2F;&#x27; &amp;&amp; opts.end === false) {\n    this.regexp.fast_slash = true;\n  }\n}\n</code></pre><p>上边是Layer的构造函数，我们可以看到这里定义handle，params，path和regexp等几个主要的属性：</p>\n<ol>\n<li>其中最重要的就是handle，它就是我们刚刚在route中创建Layer对象传入的中间件函数。</li>\n<li>params其实就是req.params，至于如何实现的我们可以以后再做探讨，今天先不做说明。</li>\n<li>path就是我们定义路由时传入的path。</li>\n<li>regexp对于Layer来说是比较重要的一个属性，因为下边进行路由匹配的时候就是靠它来搞定的，而它的值是由pathRegexp得来的，其实这个pathRegexp对应的是一个第三方模块<a href=\"https://www.npmjs.com/package/path-to-regexp\">path-to-regexp</a>，它的功能是将path转换成regexp，具体用法大家可以自行查看。</li>\n</ol>\n<p>看完属性，我们再来看看Layer有什么方法：</p>\n<pre class=\"prettyprint\"><code>Layer.prototype.match = function match(path) {\n  if (path == null) {\n    &#x2F;&#x2F; no path, nothing matches\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  if (this.regexp.fast_slash) {\n    &#x2F;&#x2F; fast path non-ending match for &#x2F; (everything matches)\n    this.params = {};\n    this.path = &#x27;&#x27;;\n    return true;\n  }\n\n  var m = this.regexp.exec(path);\n\n  if (!m) {\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  &#x2F;&#x2F; store values\n  this.params = {};\n  this.path = m[0];\n\n  var keys = this.keys;\n  var params = this.params;\n\n  for (var i = 1; i &lt; m.length; i++) {\n    var key = keys[i - 1];\n    var prop = key.name;\n    var val = decode_param(m[i]);\n\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\n      params[prop] = val;\n    }\n  }\n\n  return true;\n};\n</code></pre><p>match函数主要用来匹配path的，当我们向express发送一个http请求时，当前请求对应的是哪个路由，就是通过这个match函数来判断的，如果path中带有参数，match还会把参数提取出来赋值给params，所以说match是整个路由中很重要的一点。</p>\n<pre class=\"prettyprint\"><code>Layer.prototype.handle_error = function handle_error(error, req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length !== 4) {\n    &#x2F;&#x2F; not a standard error handler\n    return next(error);\n  }\n\n  try {\n    fn(error, req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n</code></pre><p>这个是错误处理函数，专门用来处理错误的。</p>\n<pre class=\"prettyprint\"><code>Layer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length &gt; 3) {\n    &#x2F;&#x2F; not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n</code></pre><p>从上边的代码我们可以看到调用了fn，而这个fn就是layer的handle属性，就是我们定义路由时传入的路由中间件，到这里我们总算找到了我们的路由中间件被执行的地方，是不是很兴奋。好了，到这里我们已经看完了Layer的代码，但Layer到底是做什么的呢，它和Route之间又有什么千丝万缕的联系呢，说说我的理解：</p>\n<blockquote>\n<p>每一个Layer对应一个中间件函数，Layer存储了每个路由的path和handle等信息，并且实现了match和handle的功能。而从前边我们已经知道，每个Route都会维护一个Layer数组，所有可以发现Route和Layer是一对多的关系，每个Route代表一个路由，而每个Layer对应的是路由的每一个中间件函数。</p>\n</blockquote>\n<p>讲完了Route和Layer的关系，我们再来回头看看Router和Layer的关系，我们再来看看index.js中prop.route的代码：</p>\n<pre class=\"prettyprint\"><code>proto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n</code></pre><p>从代码我们可以看出来Router每次添加一个route，都会把route包装到layer中，并且将layer添加到自己的stack中，那为什么要把route包装到layer中呢，前边我们已经仔细研究了Layer模块的代码，我们发现Layer具有match和handle的功能，这样我们就可以通过Layer的match来进行route的匹配了。这里有一个关键点我们需要特别讲解下，上边的代码中在创建Layer对象的时候传入的handle函数为<strong>route.dispatch.bind(route)</strong>，我们来看看route.js中的route.dispatch：</p>\n<pre class=\"prettyprint\"><code>Route.prototype.dispatch = function dispatch(req, res, done) {\n  var idx = 0;\n  var stack = this.stack;\n  if (stack.length === 0) {\n    return done();\n  }\n\n  var method = req.method.toLowerCase();\n  if (method === &#x27;head&#x27; &amp;&amp; !this.methods[&#x27;head&#x27;]) {\n    method = &#x27;get&#x27;;\n  }\n\n  req.route = this;\n\n  next();\n\n  function next(err) {\n    if (err &amp;&amp; err === &#x27;route&#x27;) {\n      return done();\n    }\n\n    var layer = stack[idx++];\n    if (!layer) {\n      return done(err);\n    }\n\n    if (layer.method &amp;&amp; layer.method !== method) {\n      return next(err);\n    }\n\n    if (err) {\n      layer.handle_error(err, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n</code></pre><p>我们发现dispatch中通过next()获取stack中的每一个layer来执行相应的路由中间件，这样就保证了我们定义在路由上的多个中间件函数被按照定义的顺序依次执行。到这里我们已经知道了单个路由是被如何执行的，那我们定义的多个路由之间又是如何被依次执行的呢，现在我们来看看index.js中的handle函数：</p>\n<pre class=\"prettyprint\"><code>proto.handle = function handle(req, res, out) {\n\n  &#x2F;&#x2F; middleware and routes\n  var stack = self.stack;\n\n  next();\n\n  function next(err) {\n\n    &#x2F;&#x2F; find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true &amp;&amp; idx &lt; stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n      \n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        &#x2F;&#x2F; process non-route handlers normally\n        continue;\n      }\n    }\n\n    &#x2F;&#x2F; no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    &#x2F;&#x2F; this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  }\n};\n</code></pre><p>上边的代码我进行了处理，删除了一些逻辑，只留下关键部分。从上边的代码我们可以看出，这里也是利用next()，来处理stack中的每一个Layer，这里的stack是Router的stack，stack中存贮了多个route对应的layer，获取到每个layer对象之后，用请求的path与layer进行匹配，此处匹配用的是layer.match，如果能匹配到对应的layer，则获得layer.route，如果route不为空则执行对应的<strong>layer.handle_request()</strong>，如果route为空说明这个layer是通过use()添加的非路由中间件，需要特别说明的是，如果通过use()添加的非路由中间件没有指定path，则会在layer.match中默认返回true，也就是说，没有指定path的非路由中间件会匹配所有的http请求。</p>\n<p>到这里，我们基本已经说明了router相关的所有内容，想必看到这里你一定会有点晕，我们接下来来重新梳理一下。看看express究竟是如何对http请求进行路由的。</p>\n<p>当客户端发送一个http请求后，会先进入express实例对象对应的router.handle函数中，router.handle函数会通过next()遍历stack中的每一个layer进行match，如果match返回true，则获取layer.route，执行route.dispatch函数，route.dispatch同样是通过next()遍历stack中的每一个layer，然后执行layer.handle_request，也就是调用中间件函数。直到所有的中间件函数被执行完毕，整个路由处理结束。</p>\n</div>",
      "title": "express源码分析之Router",
      "last_reply_at": "2019-07-27T04:44:16.459Z",
      "good": true,
      "top": false,
      "reply_count": 17,
      "visit_count": 17767,
      "create_at": "2016-05-26T10:19:59.631Z",
      "author": {
        "loginname": "leijianning",
        "avatar_url": "https://avatars2.githubusercontent.com/u/14830812?v=4&s=120"
      }
    },
    {
      "id": "5d3ac164b4725a628e268eff",
      "author_id": "5ad86092a7d228c16b987042",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>使用Node做服务端开发也两年多了，最近有些疑惑🤔\n1、大家都说Node的发展前景不错，但是看到大多招聘Node的都只是挂个Node的title，实际招聘的是前端或者全栈，招Node服务端的偏少，如果想使用Node做服务端开发，具体该怎样规划一下后续的学习路径？\n2、最近看了下大厂的招聘，基本还是c++、java，有大厂招Node服务端开发吗？\n3、Node的定位到底是什么？</p>\n</div>",
      "title": "Node服务端该怎样规划未来的职业方向？",
      "last_reply_at": "2019-07-27T03:26:54.997Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 474,
      "create_at": "2019-07-26T09:01:24.618Z",
      "author": {
        "loginname": "dingyuanwu",
        "avatar_url": "https://avatars0.githubusercontent.com/u/27721756?v=4&s=120"
      }
    },
    {
      "id": "5d351747b2b9222961dacd54",
      "author_id": "5c05dd981c62d8334935059c",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>本人想试着用 Nest.js + MongoDB 来写一些项目，但是百度和Google了一下，关于这个框架的中文文章有点少。</p>\n</div>",
      "title": "Nest.js 国内用的人多吗？",
      "last_reply_at": "2019-07-27T02:08:47.495Z",
      "good": false,
      "top": false,
      "reply_count": 18,
      "visit_count": 1665,
      "create_at": "2019-07-22T01:54:15.965Z",
      "author": {
        "loginname": "WuYinMan",
        "avatar_url": "https://avatars2.githubusercontent.com/u/28140607?v=4&s=120"
      }
    },
    {
      "id": "5d2bdca68a8bf909209ce406",
      "author_id": "5b0eaaf38a4f51e140d9437d",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>本篇主要介绍了 Node.js 如何与 Consul 进行集成，Consul 只是服务注册的一种实现，还有其它的例如 Zookeeper、Etcd 等，服务注册发现在微服务架构中扮演这一个重要的角色，伴随着服务的大量出现，服务与服务之间的配置管理、运维管理也变的难以维护，通过 Consul 可以解决这些问题，实现服务治理、服务监控。</p>\n<p>关于 Consul 的更多知识点不在这里赘述，但是在学习本节之前还是希望您能先了解下，请移步我之前写的 <a href=\"https://www.nodejs.red/#/microservice/consul\">微服务服务注册发现之 Consul 系列文章</a>。</p>\n<h2>初始化 Consul 客户端</h2>\n<blockquote>\n<p>初始化一个 Consul 客户端，关于 Node.js 中的 Consul 客户端以下项目使用 node-consul 模块。</p>\n</blockquote>\n<p><strong>核心配置说明</strong></p>\n<ul>\n<li>host (String, default: 127.0.0.1): 配置 Consul 地址</li>\n<li>port (Integer, default: 8500): 配置 Consul 端口</li>\n<li>secure (Boolean, default: false): 启用 HTTPS</li>\n<li>promisify (Boolean|Function, optional): 启动 Promise 风格，默认为 Callback</li>\n</ul>\n<p><strong>示例</strong></p>\n<pre class=\"prettyprint language-js\"><code>const Consul = require(&#x27;consul&#x27;);\n\nconst consul = new Consul({\n    host: &#x27;192.168.6.128&#x27;,\n    port: 8500,\n    promisify: true,\n});\n</code></pre><h2>服务注册与健康检查</h2>\n<blockquote>\n<p>注册一个服务并启动健康检查</p>\n</blockquote>\n<p><strong>核心配置说明</strong></p>\n<ul>\n<li>name (String): 注册的服务名称</li>\n<li>id (String, optional): 服务注册标识</li>\n<li>tags (String[], optional): 服务标签</li>\n<li>address (String, optional): 需要注册的服务地址（客户端）</li>\n<li>port (Integer, optional): 需要注册的服务端口（客户端）</li>\n<li>check (Object, optional): 服务的健康检查核心参数如下\n<ul>\n<li>http (String): 健康检查路径, interval 参数为必须设置</li>\n<li>interval (String): 健康检查频率</li>\n<li>timeout (String, optional): 健康检查超时时间</li>\n</ul>\n</li>\n<li>checks (Object[], optional): 如果有多个检查的路径，可采用对象数组形式，参数参照上面的 check</li>\n</ul>\n<p><strong>简单示例</strong></p>\n<pre class=\"prettyprint language-js\"><code>consul.agent.service.register({\n    name: serviceName,\n    address: &#x27;192.168.20.193&#x27;,\n    port: 3000,\n    check: {\n        http: &#x27;http:&#x2F;&#x2F;192.168.20.193:3000&#x2F;health&#x27;,\n        interval: &#x27;10s&#x27;,\n        timeout: &#x27;5s&#x27;,\n    }\n}, function(err, result) {\n    if (err) {\n        console.error(err);\n        throw err;\n    }\n\n    console.log(serviceName + &#x27; 注册成功！&#x27;);\n})\n</code></pre><h2>配置Consul管理控制台</h2>\n<p>Consul 提供了 Key/Value 存储，可以做为服务的配置中心，并且提供了 JSON、YAML、HCL 三种格式，在最早的 Consul 版本中只有一种 JSON 格式。</p>\n<p>以下是我为 Consul 管控台配置的数据，如下图所示：</p>\n<p><img src=\"//img.mukewang.com/5d273c1800011efc23081138.png\" alt=\"图片描述\"></p>\n<h2>服务配置中心实现</h2>\n<p>Consul 的 Key/Value 功能可以做为服务的配置中心，对于项目中一些可变化的参数信息，可配置在 Consul 中，这样当数据改变时候不用因为配置的更改而导致项目还要重新发布</p>\n<p><strong>获取配置信息</strong></p>\n<p>这个 Key 为我们配置的路径，例如我要获取上面配置的 User 数据，Key 就为 ‘develop/user’</p>\n<pre class=\"prettyprint language-js\"><code>consul.kv.get(key)\n</code></pre><p><strong>更新配置信息</strong></p>\n<ul>\n<li>key (String): 更新的路径，例如 ‘develop/user’</li>\n<li>value (String|Buffer): 更新的数据信息</li>\n</ul>\n<p>注意：如果我们要更新 JSON 中的某个字段，首先我们需要先通过 consul.kv.get 读取到 JSON 对象，程序处理之后，做为 set 的第二个参数进行传递更新。</p>\n<pre class=\"prettyprint language-js\"><code>consul.kv.set(&#x27;develop&#x2F;user&#x27;, JSON.stringify(user))\n</code></pre><p><strong>HTTP API 调用</strong></p>\n<p>还可以直接通过 HTTP API 接口直接调用，例如：<a href=\"http://192.168.6.128:8500/v1/kv/develop/user?raw%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%8F%AA%E6%83%B3%E7%94%A8\">http://192.168.6.128:8500/v1/kv/develop/user?raw，如果你只想用</a> Consul 做为配置中心，也可以通过简单的 HTTP API 调用将数据存入本地定时更新本地配置，但这要你自己去实现。</p>\n<p><img src=\"//img.mukewang.com/5d273c270001462510960310.png\" alt=\"图片描述\"></p>\n<h2>在Nodejs中进行测试</h2>\n<p>以下为一个简单的 Demo 展示了在 Node.js 如何与 Consul 之间进行服务注册、健康检查及配置中心的应用，可以很好的将上面讲解的理论知识进行实践。</p>\n<p><strong>封装 Consul</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; consul.js\nconst Consul = require(&#x27;consul&#x27;);\n\nclass ConsulConfig {\n    constructor () {\n        const serviceName = &#x27;consul-demo&#x27;;\n        \n        &#x2F;&#x2F; 初始化 consul\n        this.consul = new Consul({\n            host: &#x27;192.168.6.128&#x27;,\n            port: 8500,\n            promisify: true,\n        });\n        \n        &#x2F;&#x2F; 服务注册与健康检查配置\n        this.consul.agent.service.register({\n            name: serviceName,\n            address: &#x27;192.168.20.193&#x27;, &#x2F;&#x2F; 注意：192.168.20.193 为我本地的内网 ip，通过 ifconfig 查看\n            port: 3000,\n            check: {\n                http: &#x27;http:&#x2F;&#x2F;192.168.20.193:3000&#x2F;health&#x27;,\n                interval: &#x27;10s&#x27;,\n                timeout: &#x27;5s&#x27;,\n            }\n        }, function(err, result) {\n            if (err) {\n                console.error(err);\n                throw err;\n            }\n\n            console.log(serviceName + &#x27; 注册成功！&#x27;);\n        })\n    }\n    \n    async getConfig(key) {\n        const result = await this.consul.kv.get(key);\n\n        if (!result) {\n            return Promise.reject(key + &#x27;不存在&#x27;);\n        }\n\n        return JSON.parse(result.Value);\n    }\n    \n    &#x2F;&#x2F; 读取 user 配置简单封装\n    async getUserConfig(key) {\n        const result = await this.getConfig(&#x27;develop&#x2F;user&#x27;);\n\n        if (!key) {\n            return result;\n        }\n\n        return result[key];\n    }\n\n\t&#x2F;&#x2F; 更新 user 配置简单封装\n    async setUserConfig(key, val) {\n        const user = await this.getConfig(&#x27;develop&#x2F;user&#x27;);\n\n        user[key] = val;\n\n        return this.consul.kv.set(&#x27;develop&#x2F;user&#x27;, JSON.stringify(user))\n    }\n}\n\nmodule.exports = ConsulConfig;\n</code></pre><p><strong>编写启动文件</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; app.js\nconst http = require(&#x27;http&#x27;);\nconst ConsulConfig = require(&#x27;.&#x2F;consul&#x27;);\nconst consul = new ConsulConfig();\n\nhttp.createServer(async (req, res) =&gt; {\n    const {url, method} = req;\n\n    &#x2F;&#x2F; 测试健康检查\n    if (url === &#x27;&#x2F;health&#x27;) {\n        res.end(&#x27;OK!&#x27;);\n    }\n\n    &#x2F;&#x2F; 测试动态读取数据\n    if (method === &#x27;GET&#x27; &amp;&amp; url === &#x27;&#x2F;user&#x2F;info&#x27;) {\n        const user = await consul.getUserConfig();\n        res.end(&#96;你好，我是 ${user.name} 今年 ${user.age}&#96;);\n    }\n\n    &#x2F;&#x2F; 测试数据更新\n    if (method === &#x27;POST&#x27; &amp;&amp; url === &#x27;&#x2F;user&#x27;) {\n        try {\n            await consul.setUserConfig(&#x27;age&#x27;, 18) &#x2F;&#x2F; 将 age 更改为 18\n            res.end(&#x27;OK!&#x27;);\n        } catch (err) {\n            console.error(err);\n            res.end(&#x27;ERROR!&#x27;);\n        }\n    }\n}).listen(3000, &#x27;192.168.20.193&#x27;); &#x2F;&#x2F; 192.168.20.193 为我本地的内网 ip，通过 ifconfig 查看\n</code></pre><h3>接口测试</h3>\n<p><strong>健康检查接口</strong></p>\n<p>该接口在服务启动后且向 Consul 配置中心注册后，根据 consul.js 文件配置的服务注册和健康检查信息进行自动调用。</p>\n<pre class=\"prettyprint\"><code>$ curl http:&#x2F;&#x2F;192.168.20.193:3000&#x2F;health\nOK!\n</code></pre><p>注册成功后展示我们服务的名称及健康检查结果如下：</p>\n<p><img src=\"//img.mukewang.com/5d273c4d000119c919360726.png\" alt=\"图片描述\">\n<img src=\"//img.mukewang.com/5d273c5d0001616719460332.png\" alt=\"图片描述\">\n<strong>获取配置信息接口</strong></p>\n<pre class=\"prettyprint\"><code>$ curl http:&#x2F;&#x2F;192.168.20.193:3000&#x2F;user&#x2F;info\n你好，我是 Jack 今年 20\n</code></pre><p><strong>更新配置信息接口</strong></p>\n<pre class=\"prettyprint\"><code>$ curl -X POST http:&#x2F;&#x2F;192.168.20.193:3000&#x2F;user\nOK!\n</code></pre><p><strong>更新之后重新获取配置</strong></p>\n<p>可以看到使用 Consul 做为配置中心之后，在我的项目没有重启的情况下也是可以实现数据动态变更的。</p>\n<pre class=\"prettyprint\"><code>$ curl http:&#x2F;&#x2F;192.168.20.193:3000&#x2F;user&#x2F;info\n你好，我是 Jack 今年 18\n</code></pre><p>本节源码 Github 地址：<a href=\"https://github.com/Q-Angelo/project-training/tree/master/nodejs/consul-demo\">Node.js + Consul 实现服务注册、健康检查、配置中心 Demo</a></p>\n<h2>总结</h2>\n<p>总结起来本文主要讲解了 Consul 的三个功能点在 Node.js 中的应用，客户端进行服务注册成功之后，则可以在 Consul 管控台看到当前的服务列表。健康检查功能，可以检查接口的可用性，进一步还可以做运维监控报警，配置中心这个对于我们开发者是很实用的，有了它可以做一些运行时配置。</p>\n<p>Consul 的应用并非只有上面介绍的三点，通过 Consul 还可以做负载均衡、分布式锁，有没有感觉很厉害 ing，这个功能是我之前在看 Spring Cloud Consul 的时候了解到的，欢迎关注「Nodejs技术栈 」公众号，关于这些后续实践之后也会进行分享。</p>\n<h2>阅读推荐</h2>\n<ul>\n<li><a href=\"https://github.com/Q-Angelo/Nodejs-Interview-Questions\">Nodejs-Interview-Questions —专注于 Node.js 面试及常见问题分享</a></li>\n<li><a href=\"https://www.nodejs.red\">Nodejs 技术栈 — 一份 Node.js 开发与学习的技术栈指南</a></li>\n<li>关注公众号「Nodejs技术栈」为您推荐更多 Node.js 相关学习指南</li>\n<li>首发 <a href=\"https://www.imooc.com/article/289385\">慕课网</a></li>\n</ul>\n</div>",
      "title": "Node.js + Consul 实现服务注册、健康检查、配置中心",
      "last_reply_at": "2019-07-27T02:02:53.947Z",
      "good": false,
      "top": false,
      "reply_count": 14,
      "visit_count": 1510,
      "create_at": "2019-07-15T01:53:42.906Z",
      "author": {
        "loginname": "Q-Angelo",
        "avatar_url": "https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"
      }
    },
    {
      "id": "5d303e32b2b9222961dabe89",
      "author_id": "573ac2cdf610cbba1dc4519b",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><h2>问题描述</h2>\n<p>目前有一个需求，需求中涉及一个比较耗时的操作，这时候产生了两种方案，请各位大佬指导一下。</p>\n<ol>\n<li>\n<p>这个请求大概耗时在20秒左右，发起请求后前端一直转圈圈等待返回。\n质疑点：当大量用户进来后，http的连接数限制，会不会被hold住，后面的服务器请求一直等待排队。</p>\n</li>\n<li>\n<p>设计两个请求，并且在缓存中设置一个标志量，第一个请求进来触发耗时操作，并且立即返回前端”处理中“状态，然后在前端加新的轮询请求，请求缓存中的标志量，返回第一个请求的操作结果，这样可以及时释放http请求，\n质疑点：前端要多好几次轮询开销，而且如果轮询间隔时间不合适，体验也会变差。</p>\n</li>\n</ol>\n<p>大佬们给一下意见？希望能从nodejs和java对比一下，那种更合适处理这种场景。</p>\n</div>",
      "title": "高并发下场景下，使用nodejs产生的问题",
      "last_reply_at": "2019-07-27T02:01:13.769Z",
      "good": false,
      "top": false,
      "reply_count": 18,
      "visit_count": 1860,
      "create_at": "2019-07-18T09:38:58.032Z",
      "author": {
        "loginname": "FantasyGao",
        "avatar_url": "https://avatars0.githubusercontent.com/u/17523638?v=4&s=120"
      }
    },
    {
      "id": "5d3ac105b4725a628e268ef5",
      "author_id": "56fbb4a48a612c5559d16a49",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>nodejs 在中间层主要是做了两件事</strong></p>\n<h5>1.转发</h5>\n<p>转发的话性能和nginx比还是有差距的，当初我们测试代理一个静态文件，并发数和nginx是有差距的，所以这一点不是核心竞争力</p>\n<h5>2.业务logic处理</h5>\n<p>现在在创业公司野蛮生长阶段都是nodejs直接做后端，在公司扩张稳定之后便会引用go或则java做基础服务，nodejs做业务层处理，这样做主要是解决以下几个痛点</p>\n<h6>1.很多基础服务，比如用户模块，组织模块的一些基础方法在多个项目中用到，并且变动小，所以需要用go或则java沉淀出基础层，提高复用性.</h6>\n<h6>2.尽量避免很多node服务和数据库直连，保证数据库的安全性，安全性包括数据安全和性能安全。</h6>\n<h6>3.部分公司用node做数据渲染，缓存，这样可以很大程度的前端体验</h6>\n<p>3.1  比如后端返回的是json, 然后node把渲染好的页面直接返回给前端，这样能很大程度提高前端的体验\n3.2   node 结合redis可以进行某些api数据的缓存，这样提高了api响应速度</p>\n<h6>4.在复杂的单页面运用中实现路由模块管理</h6>\n<p>4.1  比如我一个项目有订单模块和产品模块，其实是两个单页，通过访问不同的nodejs路由得到，这样不用一次性全部加载到前端，提高了用户体验</p>\n</div>",
      "title": "nodejs的角色定位",
      "last_reply_at": "2019-07-27T01:48:40.054Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 424,
      "create_at": "2019-07-26T08:59:49.135Z",
      "author": {
        "loginname": "TimLiu1",
        "avatar_url": "https://avatars0.githubusercontent.com/u/16770736?v=4&s=120"
      }
    },
    {
      "id": "5b8cdb3a71b88cc417ed0846",
      "author_id": "5b74f778a210553a0cde2979",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>求告知react的入门相关书籍！！！</p>\n</div>",
      "title": "如何才能学好react？",
      "last_reply_at": "2019-07-26T15:22:10.921Z",
      "good": false,
      "top": false,
      "reply_count": 53,
      "visit_count": 5710,
      "create_at": "2018-09-03T06:56:58.686Z",
      "author": {
        "loginname": "zhuhaifeng1251pm",
        "avatar_url": "https://avatars1.githubusercontent.com/u/41354007?v=4&s=120"
      }
    },
    {
      "id": "5b7ac9c7c52ad1482eb940bf",
      "author_id": "5b52cbf1fb9e84ec69cc1ca2",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>",
      "title": "Egg.js现在用的人多吗？那些公司在用有知道的吗？",
      "last_reply_at": "2019-07-26T11:28:04.439Z",
      "good": false,
      "top": false,
      "reply_count": 133,
      "visit_count": 19289,
      "create_at": "2018-08-20T14:01:43.981Z",
      "author": {
        "loginname": "nodeper",
        "avatar_url": "https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"
      }
    },
    {
      "id": "5d3a81619969a529571d759e",
      "author_id": "5b0eaaf38a4f51e140d9437d",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>多数人都拥有自己不了解的能力和机会，都有可能做到未曾梦想的事情。 ——戴尔·卡耐基</p>\n</blockquote>\n<p>从前端转入 Node.js 的童鞋对这一部分内容会比较陌生，因为在前端中一些简单的字符串操作已经满足基本的业务需求，有时可能也会觉得 Buffer、Stream 这些会很神秘。回到服务端，如果你不想只做一名普通的 Node.js 开发工程师，你应该深入去学习一下 Buffer 揭开这一层神秘的面纱，同时也会让你对 Node.js 的理解提升一个水平。</p>\n<p><strong>作者简介</strong>：五月君，Nodejs Developer，热爱技术、喜欢分享的 90 后青年，公众号 “Nodejs技术栈”，Github 开源项目 <a href=\"https://www.nodejs.red\">https://www.nodejs.red</a></p>\n<h2>Buffer初识</h2>\n<p>在引入 TypedArray 之前，JavaScript 语言没有用于读取或操作二进制数据流的机制。 Buffer 类是作为 Node.js API 的一部分引入的，用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。这是来自 Node.js 官网的一段描述，比较晦涩难懂，总结起来一句话 <strong>Node.js 可以用来处理二进制流数据或者与之进行交互</strong>。</p>\n<p>Buffer 用于读取或操作二进制数据流，做为 Node.js API 的一部分使用时无需 require，用于操作网络协议、数据库、图片和文件 I/O 等一些需要大量二进制数据的场景。Buffer 在创建时大小已经被确定且是无法调整的，在内存分配这块 Buffer 是由 C++ 层面提供而不是 V8 具体后面会讲解。</p>\n<p>在这里不知道你是否认为这是很简单的？但是上面提到的一些关键词<code>二进制</code>、<code>流（Stream）</code>、<code>缓冲区（Buffer）</code>，这些又都是什么呢？下面尝试做一些简单的介绍。</p>\n<h3>什么是二进制数据？</h3>\n<p>谈到二进制我们大脑可能会浮想到就是 010101 这种代码命令，如下图所示：</p>\n<p><img src=\"//static.cnodejs.org/Fv63GpkB3KcXq8lc1UPpxlsRhBiq\" alt=\"010101.jpg\"></p>\n<p>正如上图所示，二进制数据使用 0 和 1 两个数码来表示的数据，为了存储或展示一些数据，计算机需要先将这些数据转换为二进制来表示。例如，我想存储 66 这个数字，计算机会先将数字 66 转化为二进制 01000010 表示，印象中第一次接触这个是在大学期间 C 语言课程中，转换公式如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>128</th>\n<th>64</th>\n<th>32</th>\n<th>16</th>\n<th>8</th>\n<th>4</th>\n<th>2</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>上面用数字举了一个示例，我们知道数字只是数据类型之一，其它的还有字符串、图像、文件等。例如我们对一个英文 M 操作，在 JavaScript 里通过 <code>'M'.charCodeAt()</code> 取到对应的 ASCII 码之后（通过以上的步骤）会转为二进制表示。</p>\n<h3>什么是 Stream？</h3>\n<p>流，英文 Stream 是对输入输出设备的抽象，这里的设备可以是文件、网络、内存等。</p>\n<p>流是有方向性的，当程序从某个数据源读入数据，会开启一个输入流，这里的数据源可以是文件或者网络等，例如我们从 a.txt 文件读入数据。相反的当我们的程序需要写出数据到指定数据源（文件、网络等）时，则开启一个输出流。当有一些大文件操作时，我们就需要 Stream 像管道一样，一点一点的将数据流出。</p>\n<p><strong>举个例子</strong></p>\n<p>我们现在有一大罐水需要浇一片菜地，如果我们将水罐的水一下全部倒入菜地，首先得需要有多么大的力气（这里的力气好比计算机中的硬件性能）才可搬得动。如果，我们拿来了水管将水一点一点流入我们的菜地，这个时候不要这么大力气就可完成。</p>\n<p><img src=\"//static.cnodejs.org/FtcuoHCLPxdEQgFQIH7xqRmrnfVg\" alt=\"fountain_stream.jpg\"></p>\n<p>通过上面的讲解进一步的理解了 Stream 是什么？那么 Stream 和 Buffer 之间又是什么关系呢？看以下介绍，关于 Stream 本身也有很多知识点，欢迎关注公众号「Nodejs技术栈」，之后会单独进行介绍。</p>\n<h3>什么是 Buffer？</h3>\n<p>通过以上 Stream 的讲解，我们已经看到数据是从一端流向另一端，那么他们是如何流动的呢？</p>\n<p>通常，数据的移动是为了处理或者读取它，并根据它进行决策。伴随着时间的推移，每一个过程都会有一个最小或最大数据量。如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理。</p>\n<p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 RAM 中。这些概念可能会很难理解，不要担心下面通过一个例子进一步说明。</p>\n<p><strong>公共汽车站乘车例子</strong></p>\n<p>举一个公共汽车站乘车的例子，通常公共汽车会每隔几十分钟一趟，在这个时间到达之前就算乘客已经满了，车辆也不会提前发车，早到的乘客就需要先在车站进行等待。假设到达的乘客过多，后到的一部分则需要在公共汽车站等待下一趟车驶来。</p>\n<p><img src=\"//static.cnodejs.org/FltfKl3MZVE8TRwGbxxbI2dtPQYj\" alt=\"bus-stop-1516549_1280.jpg\"></p>\n<p>在上面例子中的等待区公共汽车站，对应到我们的 Node.js 中也就是缓冲区（Buffer），另外乘客到达的速度是我们不能控制的，我们能控制的也只有何时发车，对应到我们的程序中就是我们无法控制数据流到达的时间，可以做的是能决定何时发送数据。</p>\n<h2>Buffer基本使用</h2>\n<p>了解了 Buffer 的一些概念之后，我们来看下 Buffer 的一些基本使用，这里并不会列举所有的 API 使用，仅列举一部分常用的，更详细的可参考 <a href=\"http://nodejs.cn/api/buffer.html\">Node.js 中文网</a>。</p>\n<h3>创建Buffer</h3>\n<p>在 6.0.0 之前的 Node.js 版本中， Buffer 实例是使用 Buffer 构造函数创建的，该函数根据提供的参数以不同方式分配返回的 Buffer <code>new Buffer()</code>。</p>\n<p>现在可以通过 Buffer.from()、Buffer.alloc() 与 Buffer.allocUnsafe() 三种方式来创建</p>\n<p><strong>Buffer.from()</strong></p>\n<pre class=\"prettyprint language-js\"><code>const b1 = Buffer.from(&#x27;10&#x27;);\nconst b2 = Buffer.from(&#x27;10&#x27;, &#x27;utf8&#x27;);\nconst b3 = Buffer.from([10]);\nconst b4 = Buffer.from(b3);\n\nconsole.log(b1, b2, b3, b4); &#x2F;&#x2F; &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt;\n</code></pre><p><strong>Buffer.alloc</strong></p>\n<p>返回一个已初始化的 Buffer，可以保证新创建的 Buffer 永远不会包含旧数据。</p>\n<pre class=\"prettyprint language-js\"><code>const bAlloc1 = Buffer.alloc(10); &#x2F;&#x2F; 创建一个大小为 10 个字节的缓冲区\n\nconsole.log(bAlloc1); &#x2F;&#x2F; &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\n</code></pre><p><strong>Buffer.allocUnsafe</strong></p>\n<p>创建一个大小为 size 字节的新的未初始化的 Buffer，由于 Buffer 是未初始化的，因此分配的内存片段可能包含敏感的旧数据。在 Buffer 内容可读情况下，则可能会泄露它的旧数据，这个是不安全的，使用时要谨慎。</p>\n<pre class=\"prettyprint language-js\"><code>const bAllocUnsafe1 = Buffer.allocUnsafe(10);\n\nconsole.log(bAllocUnsafe1); &#x2F;&#x2F; &lt;Buffer 49 ae c9 cd 49 1d 00 00 11 4f&gt;\n</code></pre><h3>Buffer 字符编码</h3>\n<p>通过使用字符编码，可实现 Buffer 实例与 JavaScript 字符串之间的相互转换，目前所支持的字符编码如下所示：</p>\n<ul>\n<li>‘ascii’ - 仅适用于 7 位 ASCII 数据。此编码速度很快，如果设置则会剥离高位。</li>\n<li>‘utf8’ - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8。</li>\n<li>‘utf16le’ - 2 或 4 个字节，小端序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>\n<li>‘ucs2’ - ‘utf16le’ 的别名。</li>\n<li>‘base64’ - Base64 编码。当从字符串创建 Buffer 时，此编码也会正确地接受 RFC 4648 第 5 节中指定的 “URL 和文件名安全字母”。</li>\n<li>‘latin1’ - 一种将 Buffer 编码成单字节编码字符串的方法（由 RFC 1345 中的 IANA 定义，第 63 页，作为 Latin-1 的补充块和 C0/C1 控制码）。</li>\n<li>‘binary’ - ‘latin1’ 的别名。</li>\n<li>‘hex’ - 将每个字节编码成两个十六进制的字符。</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>const buf = Buffer.from(&#x27;hello world&#x27;, &#x27;ascii&#x27;);\nconsole.log(buf.toString(&#x27;hex&#x27;)); &#x2F;&#x2F; 68656c6c6f20776f726c64\n</code></pre><h3>字符串与 Buffer 类型互转</h3>\n<p><strong>字符串转 Buffer</strong></p>\n<p>这个相信不会陌生了，通过上面讲解的 Buffer.form() 实现，如果不传递 encoding 默认按照 UTF-8 格式转换存储</p>\n<pre class=\"prettyprint language-js\"><code>const buf = Buffer.from(&#x27;Node.js 技术栈&#x27;, &#x27;UTF-8&#x27;);\n\nconsole.log(buf); &#x2F;&#x2F; &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;\nconsole.log(buf.length); &#x2F;&#x2F; 17\n</code></pre><p><strong>Buffer 转换为字符串</strong></p>\n<p>Buffer 转换为字符串也很简单，使用 toString([encoding], [start], [end]) 方法，默认编码仍为 UTF-8，如果不传 start、end 可实现全部转换，传了 start、end 可实现部分转换（这里要小心了）</p>\n<pre class=\"prettyprint language-js\"><code>const buf = Buffer.from(&#x27;Node.js 技术栈&#x27;, &#x27;UTF-8&#x27;);\n\nconsole.log(buf); &#x2F;&#x2F; &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;\nconsole.log(buf.length); &#x2F;&#x2F; 17\nconsole.log(buf.toString(&#x27;UTF-8&#x27;, 0, 9)); &#x2F;&#x2F; Node.js \ufffd\n</code></pre><p>运行查看，可以看到以上输出结果为 <code>Node.js \ufffd</code> 出现了乱码，为什么？</p>\n<p><strong>转换过程中为什么出现乱码？</strong></p>\n<p>首先以上示例中使用的默认编码方式 UTF-8，问题就出在这里一个中文在 UTF-8 下占用 3 个字节，<code>技</code> 这个字在 buf 中对应的字节为 <code>8a 80 e6</code>\n而我们的设定的范围为 0～9 因此只输出了 <code>8a</code>，这个时候就会造成字符被截断出现乱码。</p>\n<p>下面我们改下示例的截取范围：</p>\n<pre class=\"prettyprint language-js\"><code>const buf = Buffer.from(&#x27;Node.js 技术栈&#x27;, &#x27;UTF-8&#x27;);\n\nconsole.log(buf); &#x2F;&#x2F; &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;\nconsole.log(buf.length); &#x2F;&#x2F; 17\nconsole.log(buf.toString(&#x27;UTF-8&#x27;, 0, 11)); &#x2F;&#x2F; Node.js 技\n</code></pre><p>可以看到已经正常输出了</p>\n<h2>Buffer内存机制</h2>\n<p>在 <a href=\"https://www.nodejs.red/#/nodejs/memory\">Nodejs 中的 内存管理和 V8 垃圾回收机制</a> 一节主要讲解了在 Node.js 的垃圾回收中主要使用 V8 来管理，但是并没有提到 Buffer 类型的数据是如何回收的，下面让我们来了解 Buffer 的内存回收机制。</p>\n<p>由于 Buffer 需要处理的是大量的二进制数据，假如用一点就向系统去申请，则会造成频繁的向系统申请内存调用，所以 Buffer 所占用的内存<strong>不再由 V8 分配</strong>，而是在 Node.js 的 <strong>C++ 层面完成申请</strong>，在 <strong>JavaScript 中进行内存分配</strong>。因此，这部分内存我们称之为<strong>堆外内存</strong>。</p>\n<p><strong>注意</strong>：以下使用到的 buffer.js 源码为 Node.js v10.x 版本，地址：<a href=\"https://github.com/nodejs/node/blob/v10.x/lib/buffer.js\">https://github.com/nodejs/node/blob/v10.x/lib/buffer.js</a></p>\n<h3>Buffer内存分配原理</h3>\n<p>Node.js 采用了 slab 机制进行<strong>预先申请、事后分配</strong>，是一种动态的管理机制。</p>\n<p>使用 Buffer.alloc(size) 传入一个指定的 size 就会申请一块固定大小的内存区域，slab 具有如下三种状态：</p>\n<ul>\n<li>full：完全分配状态</li>\n<li>partial：部分分配状态</li>\n<li>empty：没有被分配状态</li>\n</ul>\n<p><strong>8KB 限制</strong></p>\n<p>Node.js 以 8KB 为界限来区分是小对象还是大对象，在 <a href=\"https://github.com/nodejs/node/blob/v10.x/lib/buffer.js\">buffer.js</a> 中可以看到以下代码</p>\n<pre class=\"prettyprint language-js\"><code>Buffer.poolSize = 8 * 1024; &#x2F;&#x2F; 102 行，Node.js 版本为 v10.x\n</code></pre><p>在 <strong>Buffer 初识</strong> 一节里有提到过 <code>Buffer 在创建时大小已经被确定且是无法调整的</code> 到这里应该就明白了。</p>\n<p><strong>Buffer 对象分配</strong></p>\n<p>以下代码示例，在加载时直接调用了 createPool() 相当于直接初始化了一个 8 KB 的内存空间，这样在第一次进行内存分配时也会变得更高效。另外在初始化的同时还初始化了一个新的变量 <strong>poolOffset = 0</strong> 这个变量会记录已经使用了多少字节。</p>\n<pre class=\"prettyprint language-js\"><code>Buffer.poolSize = 8 * 1024;\nvar poolSize, poolOffset, allocPool;\n\n... &#x2F;&#x2F; 中间代码省略\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeArrayBuffer(poolSize);\n  poolOffset = 0;\n}\ncreatePool(); &#x2F;&#x2F; 129 行\n</code></pre><p>此时，新构造的 slab 如下所示：</p>\n<p><img src=\"//static.cnodejs.org/FuH5H2NHzSCPgrJhB1gdfdMi1WHh\" alt=\"slab_poolOffset_0.png\"></p>\n<p>现在让我们来尝试分配一个大小为 2048 的 Buffer 对象，代码如下所示：</p>\n<pre class=\"prettyprint language-js\"><code>Buffer.alloc(2 * 1024)\n</code></pre><p>现在让我们先看下当前的 slab 内存是怎么样的？如下所示：</p>\n<p><img src=\"//static.cnodejs.org/Fv9nHSViTw_1F-v4OZwUPZJrSB6h\" alt=\"slab_poolOffset_2048.png\"></p>\n<p>那么这个分配过程是怎样的呢？让我们再看 buffer.js 另外一个核心的方法 allocate(size)</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;blob&#x2F;v10.x&#x2F;lib&#x2F;buffer.js#L318\nfunction allocate(size) {\n  if (size &lt;= 0) {\n    return new FastBuffer();\n  }\n\n  &#x2F;&#x2F; 当分配的空间小于 Buffer.poolSize 向右移位，这里得出来的结果为 4KB\n  if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) {\n    if (size &gt; (poolSize - poolOffset))\n      createPool();\n    var b = new FastBuffer(allocPool, poolOffset, size);\n    poolOffset += size; &#x2F;&#x2F; 已使用空间累加\n    alignPool(); &#x2F;&#x2F; 8 字节内存对齐处理\n    return b;\n  } else { &#x2F;&#x2F; C++ 层面申请\n    return createUnsafeBuffer(size);\n  }\n}\n</code></pre><p>读完上面的代码，已经很清晰的可以看到何时会分配小 Buffer 对象，又何时会去分配大 Buffer 对象。</p>\n<h3>Buffer 内存分配总结</h3>\n<p>这块内容着实难理解，翻了几本 Node.js 相关书籍，朴灵大佬的「深入浅出 Node.js」Buffer 一节还是讲解的挺详细的，推荐大家去阅读下。</p>\n<ol>\n<li>在初次加载时就会初始化 1 个 <strong>8KB 的内存空间</strong>，buffer.js 源码有体现</li>\n<li>根据申请的内存大小分为 <strong>小 Buffer 对象</strong> 和 <strong>大 Buffer 对象</strong></li>\n<li>小 Buffer 情况，会继续判断这个 slab 空间是否足够\n<ul>\n<li>如果空间足够就去使用剩余空间同时更新 slab 分配状态，偏移量会增加</li>\n<li>如果空间不足，slab 空间不足，就会去创建一个新的 slab 空间用来分配</li>\n</ul>\n</li>\n<li>大 Buffer 情况，则会直接走 createUnsafeBuffer(size) 函数</li>\n<li>不论是小 Buffer 对象还是大 Buffer 对象，内存分配是在 C++ 层面完成，内存管理在 JavaScript 层面，最终还是可以被 V8 的垃圾回收标记所回收。</li>\n</ol>\n<h2>Buffer应用场景</h2>\n<p>以下列举一些 Buffer 在实际业务中的应用场景，也欢迎大家在评论区补充！</p>\n<h3>I/O 操作</h3>\n<p>关于 I/O 可以是文件或网络 I/O，以下为通过流的方式将 input.txt 的信息读取出来之后写入到 output.txt 文件，关于 Stream 与 Buffer 的关系不明白的在回头看下 <strong>Buffer 初识</strong> 一节讲解的 <code>什么是 Stream?</code>、<code>什么是 Buffer?</code></p>\n<pre class=\"prettyprint language-js\"><code>const fs = require(&#x27;fs&#x27;);\n\nconst inputStream = fs.createReadStream(&#x27;input.txt&#x27;); &#x2F;&#x2F; 创建可读流\nconst outputStream = fs.createWriteStream(&#x27;output.txt&#x27;); &#x2F;&#x2F; 创建可写流\n\ninputStream.pipe(outputStream); &#x2F;&#x2F; 管道读写\n</code></pre><p>在 Stream 中我们是不需要手动去创建自己的缓冲区，在 Node.js 的<strong>流中将会自动创建</strong>。</p>\n<h3>zlib.js</h3>\n<p>zlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能。参考源代码 <a href=\"https://github.com/nodejs/node/blob/master/lib/zlib.js\">zlib.js 源码</a></p>\n<h3>加解密</h3>\n<p>在一些加解密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 String 或 Buffer 类型，如果是 Buffer 类型，就用到了本篇我们讲解的内容，以下做了一个简单的加密示例，重点使用了 Buffer.alloc() 初始化一个实例（这个上面有介绍），之后使用了 fill 方法做了填充，这里重点在看下这个方法的使用。</p>\n<p><strong>buf.fill(value[, offset[, end]][, encoding])</strong></p>\n<ul>\n<li>value: 第一个参数为要填充的内容</li>\n<li>offset: 偏移量，填充的起始位置</li>\n<li>end: 结束填充 buf 的偏移量</li>\n<li>encoding: 编码集</li>\n</ul>\n<p><strong>以下为 Cipher 的对称加密 Demo</strong></p>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\nconst [key, iv, algorithm, encoding, cipherEncoding] = [\n    &#x27;a123456789&#x27;, &#x27;&#x27;, &#x27;aes-128-ecb&#x27;, &#x27;utf8&#x27;, &#x27;base64&#x27;\n];\n\nconst handleKey = key =&gt; {\n    const bytes = Buffer.alloc(16); &#x2F;&#x2F; 初始化一个 Buffer 实例，每一项都用 00 填充\n    console.log(bytes); &#x2F;&#x2F; &lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;\n    bytes.fill(key, 0, 10) &#x2F;&#x2F; 填充\n    console.log(bytes); &#x2F;&#x2F; &lt;Buffer 61 31 32 33 34 35 36 37 38 39 00 00 00 00 00 00&gt;\n\n    return bytes;\n}\n\nlet cipher = crypto.createCipheriv(algorithm, handleKey(key), iv);\nlet crypted = cipher.update(&#x27;Node.js 技术栈&#x27;, encoding, cipherEncoding);\n    crypted += cipher.final(cipherEncoding);\n\nconsole.log(crypted) &#x2F;&#x2F; jE0ODwuKN6iaKFKqd3RF4xFZkOpasy8WfIDl8tRC5t0=\n</code></pre><h2>Buffer VS Cache</h2>\n<blockquote>\n<p>缓冲（Buffer）与缓存（Cache）的区别？</p>\n</blockquote>\n<p><strong>缓冲（Buffer）</strong></p>\n<p>缓冲（Buffer）是用于处理二进制流数据，将数据缓冲起来，它是临时性的，对于流式数据，会采用缓冲区将数据临时存储起来，等缓冲到一定的大小之后在存入硬盘中。视频播放器就是一个经典的例子，有时你会看到一个缓冲的图标，这意味着此时这一组缓冲区并未填满，当数据到达填满缓冲区并且被处理之后，此时缓冲图标消失，你可以看到一些图像数据。</p>\n<p><strong>缓存（Cache）</strong></p>\n<p>缓存（Cache）我们可以看作是一个中间层，它可以是永久性的将热点数据进行缓存，使得访问速度更快，例如我们通过 Memory、Redis 等将数据从硬盘或其它第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也是性能优化一个重要的点。</p>\n<p>来自知乎的一个讨论，点击 <a href=\"https://www.zhihu.com/question/26190832\">more</a> 查看</p>\n<h2>Buffer VS String</h2>\n<p>通过压力测试来看看 String 和 Buffer 两者的性能如何？</p>\n<pre class=\"prettyprint language-js\"><code>const http = require(&#x27;http&#x27;);\nlet s = &#x27;&#x27;;\nfor (let i=0; i&lt;1024*10; i++) {\n    s+=&#x27;a&#x27;\n}\n\nconst str = s;\nconst bufStr = Buffer.from(s);\nconst server = http.createServer((req, res) =&gt; {\n    console.log(req.url);\n\n    if (req.url === &#x27;&#x2F;buffer&#x27;) {\n        res.end(bufStr);\n    } else if (req.url === &#x27;&#x2F;string&#x27;) {\n        res.end(str);\n    }\n});\n\nserver.listen(3000);\n</code></pre><p>以上实例我放在虚拟机里进行测试，你也可以在本地电脑测试，使用 AB 测试工具。</p>\n<p><strong>测试 string</strong></p>\n<p>看以下几个重要的参数指标，之后通过 buffer 传输进行对比</p>\n<ul>\n<li>Complete requests:      21815</li>\n<li>Requests per second:    363.58 [#/sec] (mean)</li>\n<li>Transfer rate:          3662.39 [Kbytes/sec] received</li>\n</ul>\n<pre class=\"prettyprint\"><code>$ ab -c 200 -t 60 http:&#x2F;&#x2F;192.168.6.131:3000&#x2F;string\n</code></pre><p><img src=\"//static.cnodejs.org/FqReSOnZsnDkucE_teisabVCU2AW\" alt=\"ab_string.png\"></p>\n<p><strong>测试 buffer</strong></p>\n<p>可以看到通过 buffer 传输总共的请求数为 50000、QPS 达到了两倍多的提高、每秒传输的字节为 9138.82 KB，从这些数据上可以证明提前将数据转换为 Buffer 的方式，可以使性能得到近一倍的提升。</p>\n<ul>\n<li>Complete requests:      50000</li>\n<li>Requests per second:    907.24 [#/sec] (mean)</li>\n<li>Transfer rate:          9138.82 [Kbytes/sec] received</li>\n</ul>\n<pre class=\"prettyprint\"><code>$ ab -c 200 -t 60 http:&#x2F;&#x2F;192.168.6.131:3000&#x2F;buffer\n</code></pre><p><img src=\"//static.cnodejs.org/Fh2-jsJaODnKikg6i1gaE4kUZ3tZ\" alt=\"ab_buffer.png\"></p>\n<p>在 HTTP 传输中传输的是二进制数据，上面例子中的 /string 接口直接返回的字符串，这时候 HTTP 在传输之前会先将字符串转换为 Buffer 类型，以二进制数据传输，通过流（Stream）的方式一点点返回到客户端。但是直接返回 Buffer 类型，则少了每次的转换操作，对于性能也是有提升的。</p>\n<p>在一些 Web 应用中，对于静态数据可以预先转为 Buffer 进行传输，可以有效减少 CPU 的重复使用（重复的字符串转 Buffer 操作）。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"http://nodejs.cn/api/buffer.html\">http://nodejs.cn/api/buffer.html</a></li>\n<li><a href=\"https://book.douban.com/subject/25768396/\">深入浅出 Node.js Buffer</a></li>\n<li><a href=\"https://www.freecodecamp.org/news/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8/\">Do you want a better understanding of Buffer in Node.js? Check this out.</a></li>\n<li><a href=\"https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/\">A cartoon intro to ArrayBuffers and SharedArrayBuffers</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/v10.x/lib/buffer.js\">buffer.js v10.x</a></li>\n<li></li>\n</ul>\n<p>欢迎大家关注「Nodejs技术栈」公众号，扫描关注我哦！</p>\n<p><img src=\"//static.cnodejs.org/FkYkVKvIBvR735daeDaC2G0mI6dF\" alt=\"weixin_bottom.jpg\"></p>\n</div>",
      "title": "Node.js 中的缓冲区（Buffer）究竟是什么？",
      "last_reply_at": "2019-07-26T10:14:25.109Z",
      "good": false,
      "top": false,
      "reply_count": 11,
      "visit_count": 563,
      "create_at": "2019-07-26T04:28:17.093Z",
      "author": {
        "loginname": "Q-Angelo",
        "avatar_url": "https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"
      }
    },
    {
      "id": "5d3a95bdb4725a628e268d94",
      "author_id": "5d3a94709969a529571d75fc",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>请教下各位大佬，node作为中间层，去请求后端接口处理后返给前端，既然它还是要去请求后端接口，那它的处理能力不是还是要取决于后端吗，它是怎么提高的并发性能呢？</p>\n</div>",
      "title": "node作为中间层，是怎么提高并发处理能力的？",
      "last_reply_at": "2019-07-26T08:56:39.085Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 361,
      "create_at": "2019-07-26T05:55:09.492Z",
      "author": {
        "loginname": "wokeT",
        "avatar_url": "https://avatars3.githubusercontent.com/u/31942549?v=4&s=120"
      }
    },
    {
      "id": "5d3587f19969a529571d6546",
      "author_id": "56fbb4a48a612c5559d16a49",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>讨论：orm有什么缺点和优点</p>\n</div>",
      "title": "讨论：orm有什么缺点和优点",
      "last_reply_at": "2019-07-26T08:41:03.149Z",
      "good": false,
      "top": false,
      "reply_count": 9,
      "visit_count": 1050,
      "create_at": "2019-07-22T09:54:57.825Z",
      "author": {
        "loginname": "TimLiu1",
        "avatar_url": "https://avatars0.githubusercontent.com/u/16770736?v=4&s=120"
      }
    },
    {
      "id": "5d3aba6ab4725a628e268eb7",
      "author_id": "5a0d348fe2f4b8ea22496498",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>本文从开发流程角度分析了持续交付的实现，开发人员的沟通问题会拖延发布日期，必须客观地观察，才能了解成员之间的问题和流程缺陷，可视化的系统有助于找到问题所在，并在最短时间内解决，使用工具或系统管理工作数据是有效提高效率的方式之一。</p>\n</blockquote>\n<p>如今，许多企业组织都在实施持续交付的做法。但想要提高持续交付的效率，很多时候会觉得是在构建自动化测试和环境部署的时候出了问题，不过我们认为还有其他因素导致我们发布软件版本时有些压力和阻碍，只是不确定问题是什么。</p>\n<p>我们开始观察每一个软件版本发布过程并记录下看到的内容。例如，完成流程的每个步骤所花费的时间，是人为手动还是自动化发布，参与项目协作的人数有多少，以及发现导致新版本延迟发布的问题。一旦我们有足够的数据，我们就可以开始分析它并寻找解决方式，这些会成为我们要解决的最重要的问题。</p>\n<p>在观察时保持客观是很重要的，不要让自己的偏见掩盖实际发生的事实，特别是在尝试改进项目流程和系统时非常有价值。</p>\n<p><img src=\"//static.cnodejs.org/FvCFAirPrtQYJ7PkpzjrR_NmD5RW\" alt=\"2019-7-25-Continuous-Delivery-Model-Plutora.png\"></p>\n<h3>为什么要专注于改善我们的发布流程</h3>\n<p>原因是显而易见的，在软件版本发布时常常不像我们预计的那样顺畅，既不能无阻碍又无法实现频繁发布，从而影响了我们的交付能力。</p>\n<p>在改进的过程中，能与技术专家共同合作能更快优化发布流程。与专家合作的好处在于他们尊重数据和事实，并且也非常热衷于让事情变得更好。同时上文提到的收集了大量数据，就可以显示出我们的问题，这意味着我们专注于解决实际问题而不是假设。例如，数据显示我们在测试分段环境中部署的插件比我们想象的要少得多，因此我们就可以轻而易举地处理这个阻止我们轻松部署的问题。</p>\n<h3>稳定发布不代表所有东西都必须在现在发布</h3>\n<p>如果某些改进真的非常重要，那在最快的时间内发布是不可置疑的。问题在于，当我们想要选择本周的候选版本时，由于各种原因，团队认为需要包含最后一分钟的“紧急”更改。这意味着推迟选择发布候选版本以及对发布周期的连锁效应，或者工作必须加班加点，即便赶在最后发布了，有时也会影响版本质量。</p>\n<p>我们开始有这样的疑问，“为什么它必须在这个版本中出去？”，“如果我们本周不发布更改会怎么样？”或“它能等到下一个版本吗？”。要获取答案其实非常困难，因为对于团队来说开发已经是一个压力很大的情况，这些疑问的提出会被视作阻止他们进行更改。但事实上，当我们试图频繁地发布更改，更新迭代时，但其实是可以等待下一周时，它确实是违反了原则。因为我们会忘记了一点，软件版本发布的关键是稳定。</p>\n<p>通过讨论并提出这些问题，我们意识到有些变化根本不紧急，因此不需要赶工。这样做的好处是我们的版本更加顺畅，需要修复错误的程序更少了，显然发布的压力也减少了，然后我们可以更专注于如何进行周期性规律地发布。</p>\n<p><img src=\"//static.cnodejs.org/FtcfawJJ5uZitNuZDuUQsiHb_KFF\" alt=\"2019-7-25-devops-cycle-blog-1-1024x549.jpg\"></p>\n<h3>使用数据来识别问题和改变习惯</h3>\n<p>改变习惯是很难，因为习惯是长期这样做的结果，但你必须努力停止旧习惯并用新习惯取而代之。选择合适的时机发布可以突出发现我们的发布周期中的问题，并有助于解决修复问题。</p>\n<p>我们可以尝试一些方法来帮助我们养成良好的习惯。例如，如果参与发布过程的人员将发送电子邮件作为主要通信方法的话，那一般会有数小时的延迟。必须了解到，在收件人阅读并理解电子邮件之前，发件人其实还没有传达任何信息。如果收件人正在开会，或者每天只会定期检查电子邮件，那么可能会延迟更久才能看到它。</p>\n<p>为了改变这种电子邮件习惯，我们引入了一段时间的“物理提示”。在公众区域设立一个项目展示板，在上面写了候选版本号，每个人都可以补充和查看，信息会像涟漪一样扩散到所有人。那你就会知道整个发布周期里你的任务，以及目前的各任务进度。这也会激励你赶紧去做任何你应该做的事情，这也有助于推动版本发布流程。</p>\n<p>展示板有另一个好处，让人们面对面交谈，相互了解并开始感觉像一个团队。它帮助我们降低了因沟通不畅导致的流程拖延的风险，使我们团队合作，并帮助我们形成了更好的沟通习惯。</p>\n<p>总而言之，通过更有用的习惯来取代无效的习惯，展示板只是其中一个例子，你可以找到更多适合的“好习惯”。同时，一旦找到好习惯，那么就会形成行为雪球，在滚动中不断地变大，你甚至可以在这个好习惯的基础上再进行优化。如果你想了解更多，我强烈推荐可以在网上搜索 Helen Lisowski 的“Good of Good（Agile）Habits”研讨会。</p>\n<p><img src=\"//static.cnodejs.org/FvagUUunG0Av3uht21dMqMshkpT7\" alt=\"2019-7-25-pipeline-branching.png\"></p>\n<h3>应用科学思维方式来理解问题</h3>\n<p>当我第一次开始观察发布时，为了改进它们，我们可能不知道如何理解问题。这时候与经验丰富的敏捷专家，精益和系统思想家合作的好处就显现出来了。事实证明，我的整个观察，收集数据和分析的方法，都应用科学思维方式来理解问题的话会事半功倍。</p>\n<p>如何应用科学的思维方式来理解问题，包括你认为接下来会发生什么，并根据实际发生的事情调整你的后续步骤。它有四个主要步骤：</p>\n<h4>第1步：</h4>\n<p>设定你的此次发布的目的和内容，有哪些是挑战，有哪些是日常。对我们来说，大部分会是按需发布，但这并不意味着我们每分钟都会发布，我们可以需要找到一种顺畅无bug的方式发布我们想要的改进。</p>\n<h4>第2步：</h4>\n<p>了解项目当前的开发进度和发布状况。这就是收集和分析的数据的来源，我们基本上有一个电子表格形式的价值流程图。</p>\n<h4>第3步：</h4>\n<p>建立阶段性的小目标，即您的第一个里程碑。从你当前的状态到你的最终目标往往是一个太大的跳跃，为了取得进展，确定一个更容易实现的中间目标是有帮助的。比如对我们来说，可以将发布周期从15天减少到10天，而不是直接把目标定在3天。</p>\n<h4>第4步：</h4>\n<p>确定并执行以达到目的。这是同样需要数据分析，数据向我们展示了我们最大的问题是等待发布的队列时间过长。队列是“死”时间，在此期间没有任何事情发生，我们只是在等待下一个过程发生。所以我们就可以将第一个改进重点放在减少或消除队列时间上。</p>\n<p>通过上面描述知道我们要通过科学思维方式来实现改变，这里有一个例子，我们尝试将一个环境插件自动化安装到我们的测试板块。这听起来像是一个自动化过程，但是经过判断后，我们认为它是破坏的构建，主要原因是只支持手动进行部署，那么手动部署让工作的效率降低，结合数据分析，手动部署会让开发人员分心，导致发布进度被延迟。所以为了自动化流程 ，那必须延迟或者放弃这个环境插件的安装。</p>\n<p>目前运用工具来实现自动化进程是最快提升测试效率的一种办法，市面上也有很多能实现自动化测试功能的工具或者平台，国内有 <a href=\"https://s.growingio.com/gke2DD\">EOLINKER</a>，国外有POSTMAN 等等。所以对于在国内的环境，运用好的自动化工具，能帮你更好地实现项目运转，提高开发测试效率。有兴趣的点击了解 <a href=\"https://s.growingio.com/gke2DD\">EOLINKER</a>。</p>\n<p><img src=\"//static.cnodejs.org/FnhzGZmF5aKv7S_xDf1rkK126GPR\" alt=\"2019-7-25-cycle.jpg\"></p>\n<h3>改善版本的非技术方面的好处</h3>\n<p>显而易见的好处是缩短了周期时间。周期为10天，我们两周内不能发布超过一次。在进行了几次执行之后，当然我们不会满足，继续优化自动化交付，往后再减少一半，直到可以在一天内发布。</p>\n<h4>其他一些重要的好处包括：</h4>\n<ol>\n<li>更好的沟通和工作关系</li>\n<li>自动部署到测试暂存环境意味着团队可以更快地完成测试，从而减少周期时间和反馈循环</li>\n<li>改善我们糟糕的自动化测试</li>\n<li>将发布的成本从15天减少到1天，减少到1人等</li>\n<li>发布后需要修复缺陷的补丁较少</li>\n</ol>\n<h3>总结</h3>\n<ol>\n<li>可视化的系统和数据有助于找到问题所在，并在最短时间内解决</li>\n<li>当试图说服管理层将时间和资源投入项目时，客观数据和分析图表非常有用</li>\n<li>开放式办公室并不意味着他们沟通良好，设立展示板之类的办法可以促进团队合作</li>\n</ol>\n<p>当对持续交付复盘时，很容易只关注持续交付的技术部分，毕竟，这是大多数人和开发资源所关注的地方。但是，也请查看整个发布周期，根据在项目自动化的流程和所需时间，找到在此期间其他非技术因素阻碍了发布。了解发布周期流程中的所有步骤，找到问题并改进，再确保团队的沟通方法有效并合作，才能有助于实现持续交付。</p>\n<p><em>参考资料：Sylvia MacDonald,Continuous Delivery - It’s Not All about Tech!</em></p>\n<p><em>地址：<a href=\"https://www.infoq.com/articles/continuous-delivery-not-about-tech/\">https://www.infoq.com/articles/continuous-delivery-not-about-tech/</a></em></p>\n</div>",
      "title": "如何从开发流程层面实现更高效的持续交付",
      "last_reply_at": "2019-07-26T08:31:38.050Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 152,
      "create_at": "2019-07-26T08:31:38.050Z",
      "author": {
        "loginname": "wardennn",
        "avatar_url": "https://avatars0.githubusercontent.com/u/33686934?v=4&s=120"
      }
    },
    {
      "id": "5d39613db4725a628e268a12",
      "author_id": "50b6e92a637ffa41551f2986",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>最近一直在给后端代码，做单元测试使用的是mocha+should,写完一次以后确实很舒服。\n想给前端代码也增加单元测试。但是感觉无从下手，比如，如何检测是否绘制的对不对啊。之类的。求各位大神指点一下。或者是说有什么前端好用的测试框架求推荐</p>\n</div>",
      "title": "前端代码该如何去做单元测试",
      "last_reply_at": "2019-07-26T05:53:31.671Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 377,
      "create_at": "2019-07-25T07:58:53.522Z",
      "author": {
        "loginname": "beiyio",
        "avatar_url": "//gravatar.com/avatar/0808e2b8693f46047e56d738e12e22ee?size=48"
      }
    },
    {
      "id": "5d357754b2b9222961dad163",
      "author_id": "5c29eb723898674067a79d76",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>我最新引用了 jsonwebtoken。一直做前端写登录比较懵逼！！！\n<a href=\"https://github.com/yangcecode/nlna\">链接</a></p>\n</div>",
      "title": "最近在用 midway 写一个项目，写到登录阶段了，有大佬帮我看一下咋个逻辑吗？",
      "last_reply_at": "2019-07-26T03:10:05.360Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 992,
      "create_at": "2019-07-22T08:44:04.336Z",
      "author": {
        "loginname": "yangcecode",
        "avatar_url": "https://avatars3.githubusercontent.com/u/37173735?v=4&s=120"
      }
    },
    {
      "id": "5c1c9ab676c4964062a1c3e1",
      "author_id": "5372465f3c72496d41009adc",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>《Node.js开发实战》原书排名并发编程类榜首。有读者坐火车十小时一口气读完，欲罢不能！好不好，试读就知道。</p>\n<p><strong>62页试读下载</strong>：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a></p>\n<p><strong>读者热评</strong>：</p>\n<ul>\n<li>看的欲罢不能啊，火车上来回十个小时，把整体内容浏览了一遍，然后现在精读到第二张，发现学到了好多东西，好书。\n——京东读者 小***土</li>\n</ul>\n<ul>\n<li>粗略的看了一遍,准备细读一下,很多地方给详细讲了es6的新特性,包括let、const、还有class和promise,还讲解了async和await,反正不太需要有es6基础也能看得懂,不过都要2019了,其实这些应该是前端必备技能了吧.书写的很好,循序渐进,感觉前端在没搞懂node之前,其实并不需要去学py啊php啊之类的,语言毕竟只是工具,利用工具做事情的理念是想通的.(最后这句说给我自己的)\n——豆瓣读者 陈小土</li>\n</ul>\n<ul>\n<li>很不错的一本关于node的实战书！\n——京东读者 f***8</li>\n</ul>\n<ul>\n<li>内容由浅入深，引人入胜。\n——京东读者 d***t</li>\n</ul>\n<p><strong>京东有售</strong>：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a></p>\n<p><img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>",
      "title": "新书《Node.js开发实战》抢鲜试读",
      "last_reply_at": "2019-07-26T03:02:10.490Z",
      "good": false,
      "top": false,
      "reply_count": 26,
      "visit_count": 7762,
      "create_at": "2018-12-21T07:48:06.079Z",
      "author": {
        "loginname": "meikidd",
        "avatar_url": "https://avatars0.githubusercontent.com/u/376338?v=4&s=120"
      }
    },
    {
      "id": "5d3a6553b4725a628e268c9b",
      "author_id": "572c54718783d212174bd765",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>中间因为弄比较复杂的在线聊天，耽误了一个月，抱歉。先说下结果，目前已经在多个环境下经过验证，包括ios、Android、微信公众号、微信小程序(对，小程序也能搞纯H5项目)，都是较复杂的业务，全都是在webview下的纯H5单页项目，能够完美解决我们业务上的需求。</p>\n<p>在npm上推送了1.0.0版本，我们内部项目已经开始正式使用。欢迎使用，欢迎Star，希望能帮到你。</p>\n<p><a href=\"https://github.com/hezhongfeng/vue-page-stack\">项目地址</a></p>\n<p>不了解解决了什么问题的小伙伴可以看看<a href=\"https://segmentfault.com/a/1190000019395215\">前情提要</a></p>\n<h2>性能</h2>\n<p>先说一下大家最关心的性能问题，比<code>Vue</code>自带的<code>keep-alive</code>组件要好很多，因为<code>keep-alive</code>缓存一次之后在<code>keep-alive</code>组件<code>destroyed</code>之前所有的缓存是不会销毁的，但是<code>vue-page-stack</code>是根据UI层级关系进行缓存和销毁的。下面使用<code>vue-devtool</code>展示两者的不同</p>\n<p><img src=\"https://i.loli.net/2019/07/26/5d3a6df8bb23544915.gif\" alt></p>\n<p><img src=\"https://i.loli.net/2019/07/26/5d3a6e033cdad90872.gif\" alt></p>\n<p>通过上图我们可以清楚地看见激活组件和缓存组件的状态，<code>vue-page-stack</code>将栈上的UI存储，回退的时候再拿出来激活，并且将不用的组件缓存清除；而<code>keep-alive</code>会把你激活过的所有组件都缓存下来</p>\n<h2>原理</h2>\n<p>上次也说过了，是参考的<code>keep-alive</code>的代码，下面粘出部分代码，以供参考</p>\n<pre class=\"prettyprint\"><code>render() {\n  let key = this.$route.query[keyName];\n  const slot = this.$slots.default;\n  &#x2F;&#x2F; 获取当前页面的vnode\n  const vnode = getFirstComponentChild(slot);\n  if (!vnode) {\n    return vnode;\n  }\n  &#x2F;&#x2F; 查看当前页面是否有缓存\n  let index = getIndexByKey(key);\n  if (index !== -1) {\n    &#x2F;&#x2F; 有缓存的话就取出缓存，并且清除排在他后面的所有vnode\n    vnode.componentInstance = stack[index].vnode.componentInstance;\n    &#x2F;&#x2F; destroy the instances that will be spliced\n    for (let i = index + 1; i &lt; stack.length; i++) {\n      stack[i].vnode.componentInstance.$destroy();\n      stack[i] = null;\n    }\n    stack.splice(index + 1);\n  } else {\n    &#x2F;&#x2F; 没有缓存就是新的页面，需要存储或者是replace当前页面\n    if (history.action === config.replaceName) {\n      &#x2F;&#x2F; destroy the instance\n      stack[stack.length - 1].vnode.componentInstance.$destroy();\n      stack[stack.length - 1] = null;\n      stack.splice(stack.length - 1);\n    }\n    &#x2F;&#x2F; 向栈里面push\n    stack.push({ key, vnode });\n  }\n  vnode.data.keepAlive = true;\n  return vnode;\n}\n</code></pre><h1>vue-page-stack</h1>\n<p><a href=\"https://badge.fury.io/js/vue-page-stack\"><img src=\"https://badge.fury.io/js/vue-page-stack.svg\" alt=\"npm version\"></a></p>\n<p><a href>English</a> | 简体中文</p>\n<hr>\n<p>Vue 单页应用导航管理器，像原生app一样管理页面栈而不是销毁。</p>\n<p><img src=\"https://i.loli.net/2019/07/22/5d35618b25fb449357.gif\" alt></p>\n<h2>Example</h2>\n<p><a href=\"https://hezhongfeng.github.io/vue-page-stack-example/\">预览</a></p>\n<p><a href=\"https://github.com/hezhongfeng/vue-page-stack-example\">示例源码</a></p>\n<h2>功能特性</h2>\n<ul>\n<li>🐉在vue-router上扩展，原有导航逻辑不变</li>\n<li>⚽<code>push</code>或者<code>forward</code>的时候重新渲染页面，Stack中会添加新渲染的页面</li>\n<li>🏆<code>back</code>或者<code>go(负数)</code>的时候不会重新渲染，从Stack中读取先前的页面，会保留好先前的内容状态，例如表单内容，滚动条滑动的位置等</li>\n<li>🏈<code>back</code>或者<code>go(负数)</code>的时候会把不用的页面从Stack中移除</li>\n<li>🎓<code>replace</code>会更新Stack中当前页面</li>\n<li>🎉回退到之前页面的时候有activited钩子函数触发</li>\n<li>🚀支持浏览器的后退，前进事件</li>\n<li>🍕支持响应路由参数的变化，例如从 /user/foo 导航到 /user/bar，组件实例会被复用</li>\n<li>🐰提供路由方向的变化，可以在前进和后退的时候添加不同的动画</li>\n</ul>\n<h2>安装和用法</h2>\n<h3>安装</h3>\n<pre class=\"prettyprint\"><code>npm install vue-page-stack\n# OR\nyarn add vue-page-stack\n</code></pre><h3>使用</h3>\n<pre class=\"prettyprint\"><code>import Vue from &#x27;vue&#x27;\nimport VuePageStack from &#x27;vue-page-stack&#x27;;\n\n&#x2F;&#x2F; vue-router is necessary\nVue.use(VuePageStack, { router }); \n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; App.vue\n&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;vue-page-stack&gt;\n      &lt;router-view &gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;vue-page-stack&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n</code></pre><h3>CDN</h3>\n<pre class=\"prettyprint\"><code>&lt;script src=&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue-page-stack&#x2F;dist&#x2F;vue-page-stack.js&quot;&gt;&lt;&#x2F;script&gt;\n</code></pre><pre class=\"prettyprint\"><code>Vue.use(VuePageStack.default, { router });\n</code></pre><h2>API</h2>\n<h3>注册插件</h3>\n<p>注册的时候可以指定VuePageStack的名字和keyName</p>\n<p>use <code>Vue.use</code> to install <code>vue-page-stack</code>\n使用之前需要注册插件</p>\n<pre class=\"prettyprint\"><code>Vue.use(VuePageStack, options);\n&#x2F;&#x2F; example\nVue.use(VuePageStack, { router });\n</code></pre><p>Options 说明：</p>\n<table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>Description</th>\n<th>Type</th>\n<th>Accepted Values</th>\n<th>Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>router</td>\n<td>vue-router instance</td>\n<td>Object</td>\n<td>vue-router instance</td>\n<td>-</td>\n</tr>\n<tr>\n<td>name</td>\n<td>VuePageStack name</td>\n<td>String</td>\n<td>‘VuePageStack’</td>\n<td>‘VuePageStack’</td>\n</tr>\n<tr>\n<td>keyName</td>\n<td>stack-key name</td>\n<td>String</td>\n<td>‘stack-key’</td>\n<td>‘stack-key’</td>\n</tr>\n</tbody>\n</table>\n<p>注册的时候可以指定VuePageStack的名字和keyName</p>\n<pre class=\"prettyprint\"><code>Vue.use(VuePageStack, { router, name: &#x27;VuePageStack&#x27;, keyName: &#x27;stack-key&#x27; });\n</code></pre><h3>前进和后退</h3>\n<p>如果想在页面前进或者后退的时候添加一些动画，可以通过<code>stack-key-dir</code>进行判断</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; App.vue\n$route(to, from) {\n  if (to.params[&#x27;stack-key-dir&#x27;] === &#x27;forward&#x27;) {\n    this.transitionName = &#x27;forward&#x27;;\n  } else {\n    this.transitionName = &#x27;back&#x27;;\n  }\n}\n</code></pre><p><a href=\"https://github.com/hezhongfeng/vue-page-stack-example/blob/master/src/App.vue\">example</a></p>\n<h2>相关说明</h2>\n<h3>keyName</h3>\n<p>为什么会给路由添加<code>keyName</code>这个参数，是为了支持浏览器的后退，前进事件，这个特性在webApp,微信公众号和小程序很重要</p>\n<h3>原理</h3>\n<p>获取当前页面实例部分参考了<code>Vue</code>源码中<code>keep-alive</code>的部分</p>\n<h2>感谢</h2>\n<p>这个插件同时借鉴了<a href=\"https://github.com/zack24q/vue-navigation\">vue-navigation</a>和<a href=\"https://github.com/nearspears/vue-nav\">vue-nav</a>，很感谢他们给的灵感。</p>\n</div>",
      "title": "【vue-page-stack】Vue 单页应用导航管理器 正式发布",
      "last_reply_at": "2019-07-26T02:28:35.812Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 206,
      "create_at": "2019-07-26T02:28:35.812Z",
      "author": {
        "loginname": "hezhongfeng",
        "avatar_url": "https://avatars2.githubusercontent.com/u/12163050?v=4&s=120"
      }
    },
    {
      "id": "5d3a632db4725a628e268c84",
      "author_id": "5cf0fa211fe902120f31b023",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtSpH4yOeWtBNlcGKk31_DuKztlP\" alt=\"VCG41N1069771644.jpg\"></p>\n<h3>导 语</h3>\n<p>继支持小程序开发之后，云开发也支持Web使用啦！开发者们可以使用云开发提供的云端能力，直接开发网站应用，如PC端网页、公众号中的网页等。由此开发者可以在网站应用中借助云函数实现业务逻辑，通过与云数据库、对象存储以及CDN等产品联动，即可实现产品快速上线和迭代。快来体验吧！</p>\n<p>首先，还是得跟各位小伙伴们介绍下功能强大的云开发到底是何方神圣！</p>\n<p>云开发（Tencent CloudBase）是腾讯云为移动开发者提供的一站式后端云服务，无需搭建服务器，就可以轻松使用云端能力。基于云开发，开发者无需再关心服务器和底层设施运维，只需专注于代码逻辑和业务本身。</p>\n<p>目前云开发支持 <strong>小程序开发</strong> 和 <strong>Web开发</strong>。</p>\n<h3>云开发三大基础功能</h3>\n<p>目前云开发提供了三大基础能力：<strong>云数据库</strong>、<strong>云存储</strong>及<strong>云函数</strong>。这三种能力可以构成较完整的后端开发能力。</p>\n<h4>云函数</h4>\n<p>在云端运行的代码，开发者只需编写自身业务逻辑代码。</p>\n<p>云端运行：无需采购、部署、运维传统硬件，节约人力及成本。\n高效开发：每个函数单独运行、部署，上传代码后即可自动部署，提升了独立开发和迭代的速度。\n弹性伸缩：根据请求量实现毫秒级实时弹性伸缩，函数未执行不产生任何费用。</p>\n<h4>云数据库</h4>\n<p>文档型数据库包含多个近似于 JSON 数组的集合，数组中的对象是记录，格式为 JSON 文档。</p>\n<p>简单易用：数据库 API 包含增删改查，操作简单；支持触发器，满足特殊场景。\n权限控制：通过 API 在客户端内和云函数内进行数据操作，安全可靠。</p>\n<h4>云存储</h4>\n<p>在网站应用前端直接上传或下载云端文件，在云开发控制台可视化管理。</p>\n<p>快速上传：提供文件存储空间，可在客户端和云函数端通过 API 使用存储。\n权限管理：基于用户身份的安全控制，带权限管理的云端下载。\nCDN 加速：存储内的文件，天然 CDN 加速，提升用户体验。</p>\n<h3>云开发优势</h3>\n<p><strong>开发更简单</strong>\n使用云函数时，用户只需编写最重要的核心业务代码，不再需要关心负载均衡、自动伸缩、网关等组件，也无需构建应用的后端服务，极大地降低了后端开发搭建的复杂性。无需手动配置，云函数即可根据请求量自动横向扩缩，自动安排合理的计算资源满足业务需求。</p>\n<h4>开发更高效快捷</h4>\n<p>云函数不要求特定框架或依赖，开发者可以专注于核心代码的开发。同时开发人员可以组成多个小团队，单个模块的开发无需了解其他团队的代码细节。\n独立开发和迭代的速度变得前所未有的快，帮助用户把握住产品上线的黄金时间。开发可以使用云函数编写一些目的单一、逻辑独立的业务模块，因而可以完全复用已经成熟的第三方代码实现。</p>\n<p><strong>运维更省事</strong>\n每个云函数都是单独运行、单独部署、单独伸缩，用户上传代码后即可自动部署，免除单体式应用部署升级难的问题。\n用户不再需要对 OS 入侵、登录风险、文件系统安全、网络安全和端口监听做复杂的配置和管理，一切交由平台处理，平台通过定制化的容器保证每个用户的隔离性。</p>\n<p><strong>成本更低</strong>\n按请求数和资源端运行收费，极大节约时间和成本，同时还提供一定量端免费额度。</p>\n<h3>如何开通云开发的Web端服务？</h3>\n<p>云开发Web端服务在腾讯云官网登录使用。目前，云开发Web 端仅支持通过微信公众号登录方式进行服务端访问授权，故开发者若要开发网站应用，需要先在微信公众平台/微信开放平台进行应用注册及开通。</p>\n<p>（详细开通流程可参考下图）\n<img src=\"//static.cnodejs.org/Fs97pO6g3Dk1n474hnbEEjfdJvLD\" alt=\"image.png\">\n进入云开发主页</p>\n<p><img src=\"//static.cnodejs.org/FjNoPwzx3oRL-Iz5s4ujjLOadqFr\" alt=\"image.png\">\n选择“微信公众号”登录</p>\n<p><img src=\"//static.cnodejs.org/FoWq47r9JnRZGz-Knti2mVvYG0Q4\" alt=\"image.png\">\n点击授权</p>\n<p><img src=\"//static.cnodejs.org/FvaNg5zhNZcahXx2biEK1B_K9dWi\" alt=\"image.png\">\n进入云开发控制台，新建环境</p>\n<p><img src=\"//static.cnodejs.org/FnT0-skVv4cjMmHre-74Ud4Wmluu\" alt=\"image.png\">\n填写环境信息，开通成功！</p>\n<h3>Quick Start——使用云开发Web SDK 快速开发网站应用</h3>\n<h4>初始化云开发能力</h4>\n<p><img src=\"//static.cnodejs.org/FmqSrkbhK_WGLq3uWEQkDKDavxqb\" alt=\"image.png\"></p>\n<h4>登录授权</h4>\n<p>云开发目前在 Web 端支持通过微信登录方式进行服务端访问授权，故开发者若要开发网站应用，需要先在微信公众平台/微信开放平台进行应用注册及开通。</p>\n<p>除了微信公众平台和微信开放平台登录方式以外，云开发将陆续支持邮箱、QQ、匿名登录、自定义登录等多种登录方式，敬请期待。\n<img src=\"//static.cnodejs.org/FnBjutjAAI6f6wkVdVVwz97pPCLV\" alt=\"image.png\"></p>\n<h4>应用关联</h4>\n<p>要使用云开发提供的云函数、云存储和云数据库的功能，您需要先将云开发添加到您的网站应用中，即应用关联。将云开发提供的 Web 端 SDK 关联到您的网站应用，才能使客户端通过 SDK 操作后台资源。复制下方的代码片段，粘贴到您的 HTML 代码底部（要在其他 script 标记之前），即可将云开发添加至您的网站应用。\n<img src=\"//static.cnodejs.org/Fkkf3n3byhHktpSwNp0qhhv6GoS-\" alt=\"image.png\"></p>\n<h4>域名授权</h4>\n<p>为了增加安全性，云开发的身份验证服务需要先对网站应用来源进行验证，也即是域名授权。只有已授权域名下的页面才可以使用 SDK 发起对云开发服务的访问。将网站完整域名添加到安全验证到白名单中，即完成授权。\n<img src=\"//static.cnodejs.org/FqJzoA41QCh3qDhkWF9NovL-LmoQ\" alt=\"image.png\"></p>\n<h4>操作数据库</h4>\n<p>快速完成对数据库基础的 CRUD 及服务端时间（serverDate）、正则查找（regExp）和地理位置（geo）等特殊数据结构的使用。\n<img src=\"//static.cnodejs.org/Fvbs02rWViGuuxa9sP4Aba2hKudY\" alt=\"image.png\"></p>\n<h4>操作文件存储</h4>\n<p>快速完成文件上传、获取下载链接或者删除文件等操作。\n<img src=\"//static.cnodejs.org/FnaCckr7RvTJlV23jTBwieFPAmqe\" alt=\"image.png\"></p>\n<h4>操作云函数</h4>\n<p>快速实现对云函数的安全调用。\n<img src=\"//static.cnodejs.org/FmRcakslPU3gEzYK0DW3LxlV2rWs\" alt=\"image.png\"></p>\n<p>关于新开放Web端云开发服务有任何问题欢迎在下方留言，我们会尽快回复~</p>\n<p>如果你有关于使用云开发CloudBase相关的技术故事/技术实战经验想要跟大家分享，欢迎留言联系我们哦~比心！\n<img src=\"//static.cnodejs.org/FvaF3l3tGIUaCxEYFOgKH_ikjEpm\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FlswPcCJL7mOa5IQ8z783wockhj8\" alt=\"image.png\"></p>\n</div>",
      "title": "开发者福音！面向Web场景的云开发服务正式开放！",
      "last_reply_at": "2019-07-26T02:19:25.384Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 246,
      "create_at": "2019-07-26T02:19:25.384Z",
      "author": {
        "loginname": "TencentTCB",
        "avatar_url": "https://avatars0.githubusercontent.com/u/51230659?v=4&s=120"
      }
    },
    {
      "id": "5d18d23acdb1f967c157712a",
      "author_id": "58cdfd7528be82df16560950",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>最近开始着手使用 Rust 从零开始编写一个 JavaScript 引擎，目的就是将自己的 JavaScript level 提升到 “熟练”。初版的定位是可以跑通 ES5 的版本，并且尽可能多的跑过 test262 测试。</p>\n<p>目前已经完成了 Parser 部分，下一步考虑加入简单实现的 GC，并完成解释器的部分，最后就是跑 test262 测试。大概会在初版完成后写一个系列来记录并介绍如何从零开始编写 JavaScript 引擎。欢迎沟通交流指教 😀</p>\n<p><a href=\"https://github.com/hsiaosiyuan0/naive\">https://github.com/hsiaosiyuan0/naive</a></p>\n</div>",
      "title": "使用 Rust 从零开始编写 JavaScript 引擎",
      "last_reply_at": "2019-07-26T01:23:43.668Z",
      "good": false,
      "top": false,
      "reply_count": 12,
      "visit_count": 2005,
      "create_at": "2019-06-30T15:16:10.507Z",
      "author": {
        "loginname": "hsiaosiyuan0",
        "avatar_url": "https://avatars0.githubusercontent.com/u/22588905?v=4&s=120"
      }
    },
    {
      "id": "5ce3bbbfe57aac76fed2ca9b",
      "author_id": "5ce3bafde57aac76fed2ca85",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>VUE怎么学习？</p>\n</div>",
      "title": "VUE怎么学习？",
      "last_reply_at": "2019-07-26T00:48:21.881Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 893,
      "create_at": "2019-05-21T08:50:07.795Z",
      "author": {
        "loginname": "luobo007",
        "avatar_url": "https://avatars3.githubusercontent.com/u/7908554?v=4&s=120"
      }
    },
    {
      "id": "588465891dc8ff8739cbc583",
      "author_id": "5706302493a6967159553ce1",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>NPM 如何引入未发布的模块？？</p>\n<p>比如我现在有个项目有 X，里面有引入了模块A,B，</p>\n<p>本地开发了一个模块C，但是这个模块还没有发布到NPM上面，</p>\n<p>现在想C代码修改后，不需要发布到NPM上面，X项目就可以用C模块的代码了，能够建立类似maven的私人仓库？</p>\n<p>备注: C模块不在一台机器</p>\n</div>",
      "title": "NPM 如何引入未发布的模块",
      "last_reply_at": "2019-07-25T16:12:07.633Z",
      "good": false,
      "top": false,
      "reply_count": 15,
      "visit_count": 5570,
      "create_at": "2017-01-22T07:55:53.793Z",
      "author": {
        "loginname": "yuexing0921",
        "avatar_url": "https://avatars3.githubusercontent.com/u/18208187?v=4&s=120"
      }
    },
    {
      "id": "5d39c5259969a529571d73a8",
      "author_id": "58cdfd7528be82df16560950",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>很多分享都会解释什么是闭包，不得不说大都管中窥豹。比如某 star 1k 的项目中描述</p>\n<blockquote>\n<p>所有函数都是闭包</p>\n</blockquote>\n<p>是不恰当的。但是在有 1k stars 的情况下，居然没有 issue 指出其中的错误。</p>\n<p>首先必须说，闭包就取名和中文翻译而言，在你正在理解了它之后，会发现它恰到好处。如果你还觉得命名很奇怪，那么就说明你并不理解它。</p>\n<p>就如同它的名字描述的一般，闭包表示的是一个封闭的内存空间。每个函数被创建的时候，都有一个与之关联的闭包。在了解闭包的使用场景之前，先看下面一个例子：</p>\n<pre class=\"prettyprint language-js\"><code>function f() {\n  var i = 0;\n  console.log(i);\n}\n\nf();\n</code></pre><p>这段代码非常简单。我们知道一旦 <code>f</code> 执行完毕，那么它本次执行的栈上的数据将会被释放，所以每次调用结束后，栈上的 <code>i</code> 都会被及时的释放。</p>\n<p>再来看另一个例子：</p>\n<pre class=\"prettyprint language-js\"><code>function f() {\n  var i = 0;\n  return function () { &#x2F;&#x2F; f1\n    console.log(i);\n  }\n}\n\nvar ff = f();\nff();\n</code></pre><p>和第一个例子一样，这段代码同样会打印 <code>0</code>。但是这似乎打破了我们第一个例子的总结，按照第一个例子的说法，<code>f</code> 运行结束后，本次调用的栈上的 <code>i</code> 应该被释放掉了。但是我们随后调用返回的匿名函数，发现并没有报错，这就归功于闭包。</p>\n<p>每个函数被创建的时候，都会有一个与之关联的闭包被同时创建。在新创建的函数内部，如果引用了外部作用域中的变量，那么这些变量都会被添加到该函数的闭包中。</p>\n<p>注意上面代码的注释，为了方便描述，我们将匿名函数取名为 <code>f1</code>。当 <code>f</code> 被调用的时候，<code>f1</code> 被创建，同时与之关联的闭包也被创建。由于 <code>f1</code> 内部引用了位于其作用域之外的、<code>f</code> 作用域中的变量 <code>i</code>，因此 <code>f</code> 作用域中的 <code>i</code> 被拷贝到了 <code>f1</code> 的闭包中。这就解释了，为什么 <code>f</code> 执行完成之后，调用 <code>f1</code> 依然可以打印 <code>0</code>。</p>\n<p>现在来看一下第三个例子：</p>\n<pre class=\"prettyprint language-js\"><code>function f() {\n  var i = 0;\n  function f1() { \n    console.log(i);\n  }\n  i = 1;\n  return f1;\n}\n\nvar ff = f();\nff();\n</code></pre><p>我们会发现打印 <code>1</code>。好像又与第二个例子的结论有些冲突，<code>f</code> 中的 <code>i</code> 不是被拷贝到了 <code>f1</code> 的闭包中吗？为什么不是打印 <code>0</code> 而是打印 <code>1</code> 呢？</p>\n<p>这是因为，我们还没有介绍发生拷贝的时机。如果新创建的函数，引用了外部作用域的变量，并且该变量为活动的，那么并不急于将该变量的内容拷贝到闭包中，而是将该变量所指向的内存单元的地址保存于闭包中。比如我们这里，只是先将 <code>i</code> 所绑定到的内存地址保存于闭包中，等到 <code>i</code> 为非活动状态时，才会进行拷贝。也就是这里，当 <code>f</code> 即将运行结束时，<code>i</code> 的将变为非活动状态，那么需要将其内容拷贝到引用它的闭包中，也就是这里的 <code>f1</code> 的闭包中。一旦内容被拷贝到闭包中，除了与之关联的函数对象之外，再也没有其他方式可以访问到其中的内容。</p>\n<p>顺便介绍一下，那么闭包中占用的内存何时才会被释放呢？答案就是当与它关联的函数对象被释放的时候。比如我们接着上面的例子运行：</p>\n<pre class=\"prettyprint language-js\"><code>var ff = null\n</code></pre><p>我们将引用 <code>f1</code> 的变量 <code>ff</code> 赋值为 <code>null</code>，这样就没有任何变量引用 <code>f1</code> 了，所以 <code>f1</code> 成为了垃圾，会在未来的某个时间点(具体要看 GC 的实现以及运行情况)，由垃圾回收器进行所占内存回收。</p>\n<p>上面的例子，其实就是下面的例子的简化版：</p>\n<pre class=\"prettyprint language-js\"><code>function f() {\n  var a = [];\n  for(var i = 0; i &lt; 2; i++) {\n    var ff = function () {\n      console.log(i)\n    };\n    a.push(ff);\n  }\n  return a;\n}\n\nconst [f1, f2] = f();\nf1();\nf2();\n</code></pre><p>这里新创建的两个函数都会打印 <code>2</code>，想必这个例子大家都很熟悉了，就不再赘述了。只是有一个问题需要注意，既然上面提到了说，新创建的函数引用的外部作用域上的变量内容、最终都会拷贝到该函数的闭包中，那么上面的例子中，<code>i</code> 是不是被拷贝了两次？</p>\n<p>再来看一个例子：</p>\n<pre class=\"prettyprint language-js\"><code>function f() {\n  var a = [];\n  for(var i = 0; i &lt; 2; i++) {\n    var ff = function () {\n      console.log(i)\n    };\n    a.push(ff);\n  }\n  a.push(function () {\n    i++;\n  });\n  return a;\n}\n\nconst [f1, f2, f3] = f();\nf1();\nf3();\nf2();\n</code></pre><p>这个例子会打印什么？答案是 <code>2</code> 和 <code>3</code>。这是因为闭包的另一个机制，同一个变量被引用它的多个闭包所共享。我们在 <code>for</code> 循环内部创建了两个函数，在循环外部创建了一个函数，这三个函数的都引用了 <code>f</code> 中的 <code>i</code>，因而 <code>i</code> 被这三个函数的闭包所共享，也就是说在 <code>i</code> 离开自己所属的作用域时(<code>f</code> 退出前)，将只会发生一次拷贝，并将新创建的三个函数的闭包中的 <code>i</code> 的对应的指针设定为那一份拷贝的内存地址即可。对于这一个共享的拷贝地址，除了这三个闭包之外，没有其他方式可以访问到它。</p>\n<p>必须再次强调的是，被引用的变量拷贝到闭包中的时机发生在、被引用的变量离开自己所属的作用域时，即状态为非活动时。考虑下面的例子：</p>\n<pre class=\"prettyprint language-js\"><code>function f() {\n  const a = [];\n  for(let i = 0; i &lt; 2; i++) {\n    var ff = function () {\n      console.log(i)\n    };\n    a.push(ff);\n  }\n  return a;\n}\n\nconst [f1, f2] = f();\nf1();\nf2();\n</code></pre><p>我们知道 ES6 中引入了 <code>let</code> 关键字，由它声明的变量所属块级作用域。在上面的例子中，我们在 <code>for</code> 循环体的初始化部分使用了 <code>let</code>，这样一来 <code>i</code> 的作用域被设定为了该循环的块级作用域内。不过另一个细节是，循环体中的 <code>i</code> ，也就是 <code>ff</code> 中引用的 <code>i</code>，在每次迭代中都会进行重新绑定，换句话说循环体中的 <code>i</code> 的作用域是每一次的迭代。因此在循环体中，当每次迭代的 <code>i</code> 离开作用域时，它的状态变为非活动的，因此它的内容被拷贝到引用它的闭包中。</p>\n<p>闭包常常会和 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/IIFE\">IIFE</a> 一起使用，比如：</p>\n<pre class=\"prettyprint language-js\"><code>var a = [];\nfor(var i = 0; i &lt; 2; i++) {\n  a.push((function (i) { &#x2F;&#x2F; f1, i1\n    return function () { &#x2F;&#x2F; f2\n      console.log(i) &#x2F;&#x2F; i2\n    }\n  })(i)); &#x2F;&#x2F; i3\n};\n\nconst [f1, f2] = a;\nf1();\nf2();\n</code></pre><p>在上面的例子中，让人迷惑的除了闭包的部分之外，就是 <code>i1</code>，<code>i2</code> 和 <code>i3</code> 了。</p>\n<ul>\n<li><code>i1</code> 是 <code>f1</code> 的形参</li>\n<li><code>i2</code> 是 <code>f2</code> 中对外层作用域中的变量的引用</li>\n<li><code>i3</code> 是全局的变量 <code>i</code>，IIFE 执行时 <code>i</code> 对应的值将被作为实参来调用 <code>f1</code></li>\n<li>当 <code>f1</code> 被调用时，也就是 IIFE 执行阶段，它内部创建了一个新的函数 <code>f2</code>，同时也创建了 <code>f2</code> 对应的闭包</li>\n<li>由于 <code>f2</code> 中引用了外层作用域中的 <code>i</code>，即 <code>f1</code> 执行期间的 <code>i</code>，且 <code>i</code> 为活动内容，所以 <code>f2</code> 的闭包中添加一条 Key 为 <code>i</code>，Value 为指向 <code>f1</code> 中活动的 <code>i</code> 绑定到的内存单元的地址</li>\n<li>当 IIFE 执行完毕，即 <code>f1</code> 要退出的时候，其栈上活动对象 <code>i</code> 就会离开作用域，因此需要将 <code>i</code> 拷贝到引用它的闭包中。</li>\n</ul>\n<p>到目前为止，我们看到的例子都引用的直接外层作用域中的变量，那么我们再来看一个例子：</p>\n<pre class=\"prettyprint language-js\"><code>function f(x) { &#x2F;&#x2F; f1\n  return function (y) { &#x2F;&#x2F; f2\n    return function (z) { &#x2F;&#x2F; f3\n      console.log(x + y + z)\n    }\n  }\n}\n\nconst xy = f(1);\nconst xyz = xy(2);\nxyz(3);\n</code></pre><p>为了方便描述，我们分别标记了 <code>f1</code>，<code>f2</code>，<code>f3</code>。我们在 <code>f3</code> 内部，引用了 <code>x</code> 和 <code>y</code>，并且 <code>x</code> 并不是 <code>f3</code> 的直接外部作用域。那么这个闭包的构建过程时怎样的？</p>\n<p>在 JS 中，函数也是以对象的形式存在的，如果将与函数关联的闭包想象成函数对象的一个类型为 Map&lt;string, Value&gt; 的属性也不过份，比如：</p>\n<pre class=\"prettyprint language-ts\"><code>const CLOSURE = Symbol(&#x27;closure&#x27;);\nconst FUN_BODY = Symbol(&#x27;fun-body&#x27;);\nconst FUN_PARAMS = Symbol(&#x27;fun-params&#x27;);\n\nconst funObj = {\n  [FUN_PARAMS]: [&#x2F;* parameters list *&#x2F;],\n  [FUN_BODY]: [&#x2F;* instructions *&#x2F;],\n  [CLOSURE]: new Map&lt;string, Value&gt;(), &#x2F;&#x2F; Value 可以被多个 closure 共享\n}\n</code></pre><p>即使在引擎的实现阶段，因为性能或者实现差异不采用这样的设计，但本质上与这个结构含义是一致的。为了能在运行阶段创建函数对象，在编译阶段就需要收集到必要的信息：</p>\n<ul>\n<li>形参列表</li>\n<li>函数体</li>\n<li>引用的外部变量</li>\n</ul>\n<p>比如在编译 <code>f3</code> 的阶段，我们发现它内部引用了外部的 <code>x</code> 和 <code>y</code>，由于 <code>x</code> 不是直接存在于父及作用域 <code>f2</code> 中的，为了使得未来使用 <code>f2</code> 创建 <code>f3</code> 的时候，仍能够找到 <code>x</code> 的绑定，我们需要将 <code>x</code> 加入到 <code>f2</code> 的闭包中。所以在编译阶段，我们会在 <code>f2</code> 的信息中标注它内部引用了外部变量 <code>x</code>。这样在创建 <code>f2</code> 的时候，<code>x</code> 就会被拷贝到它的闭包中了，等到使用它再创建 <code>f3</code> 的时候，<code>f3</code> 中的 <code>x</code> 也就有了着落。</p>\n<p>最后来一个拓展练习：</p>\n<pre class=\"prettyprint language-js\"><code>function f(x) { \n  return [\n    function () { x++ }, \n    function (y) { \n      return function (z) { \n        console.log(x + y + z)\n      }\n    }\n  ]\n}\n\nconst [f1, xy] = f(1);\nconst xyz = xy(2);\nf1();\nxyz(3);\n</code></pre><p>如果想要了解跟多引擎层面实现闭包的细节，可以参考我的另外的项目，<a href=\"https://github.com/hsiaosiyuan0/naive\">Naive - 使用 Rust 编写的 JS 引擎</a></p>\n</div>",
      "title": "关于闭包其余凑标题字数",
      "last_reply_at": "2019-07-25T15:05:09.586Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 275,
      "create_at": "2019-07-25T15:05:09.586Z",
      "author": {
        "loginname": "hsiaosiyuan0",
        "avatar_url": "https://avatars0.githubusercontent.com/u/22588905?v=4&s=120"
      }
    },
    {
      "id": "5d3973569969a529571d7270",
      "author_id": "5836b3846add41f206000bf0",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我理解三者都可以做集成测试吧</p>\n</div>",
      "title": "前端测试工具karma、pupeteer、nightwatch区别是什么？",
      "last_reply_at": "2019-07-25T11:17:22.257Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 307,
      "create_at": "2019-07-25T09:16:06.731Z",
      "author": {
        "loginname": "victoryboss",
        "avatar_url": "https://avatars0.githubusercontent.com/u/5610115?v=4&s=120"
      }
    },
    {
      "id": "5d25526f71951f750ccb9f29",
      "author_id": "5b03c9a7000332b81cf821a5",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>为什么大公司偏向于用go,小公司偏向于node</p>\n</div>",
      "title": "为什么大公司偏向于用go,小公司偏向于node",
      "last_reply_at": "2019-07-25T09:52:01.894Z",
      "good": false,
      "top": false,
      "reply_count": 13,
      "visit_count": 2842,
      "create_at": "2019-07-10T02:50:23.204Z",
      "author": {
        "loginname": "linxiaoziruo",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"
      }
    },
    {
      "id": "5d312d93b2b9222961dac21d",
      "author_id": "5c29eb723898674067a79d76",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>controller 里面写逻辑  service 里面操作数据库</p>\n</div>",
      "title": "controller 和 service 怎么区分呢？",
      "last_reply_at": "2019-07-25T07:07:14.440Z",
      "good": false,
      "top": false,
      "reply_count": 15,
      "visit_count": 2177,
      "create_at": "2019-07-19T02:40:19.145Z",
      "author": {
        "loginname": "yangcecode",
        "avatar_url": "https://avatars3.githubusercontent.com/u/37173735?v=4&s=120"
      }
    },
    {
      "id": "5d3903029969a529571d704f",
      "author_id": "5d3901ca9969a529571d7033",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我在vs code学习nestjs项目时，import引入模块时，编辑器提示的绝对路径如“src/confg/config.service”，这种会报错模块找不到.请问是需要怎么配置一下tsconfig.json吗？</p>\n</div>",
      "title": "求大佬解惑",
      "last_reply_at": "2019-07-25T07:06:27.768Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 381,
      "create_at": "2019-07-25T01:16:50.874Z",
      "author": {
        "loginname": "gebeibei",
        "avatar_url": "https://avatars0.githubusercontent.com/u/25855912?v=4&s=120"
      }
    },
    {
      "id": "5b8de66137b3005a0b0e6b3f",
      "author_id": "5b8de41bbf116a8c0e42579f",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href=\"https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w\">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href=\"https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg\">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href=\"https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf\">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src=\"//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3\" alt=\"egg01.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE\" alt=\"egg02.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd\" alt=\"egg03.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5\" alt=\"egg05.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"222.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"06.png\"></p>\n</div>",
      "title": "Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢",
      "last_reply_at": "2019-07-25T04:13:58.142Z",
      "good": false,
      "top": false,
      "reply_count": 97,
      "visit_count": 16482,
      "create_at": "2018-09-04T01:56:49.179Z",
      "author": {
        "loginname": "zlyuanteng",
        "avatar_url": "https://avatars0.githubusercontent.com/u/42952042?v=4&s=120"
      }
    },
    {
      "id": "5d36abddffed731686461bd8",
      "author_id": "5c05dd981c62d8334935059c",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>请问博客文章的阅读量如何计算和实现才是最合适的？</p>\n</div>",
      "title": "请问博客文章的阅读量如何计算和实现才是最合适的？",
      "last_reply_at": "2019-07-25T03:32:48.694Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 527,
      "create_at": "2019-07-23T06:40:29.132Z",
      "author": {
        "loginname": "WuYinMan",
        "avatar_url": "https://avatars2.githubusercontent.com/u/28140607?v=4&s=120"
      }
    },
    {
      "id": "5d381ee5b4725a628e26866d",
      "author_id": "581378c0cf18d0333412d2a2",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>nodej 如何实现将二进制文件转换为SQLite数据库之间相互转换</p>\n</div>",
      "title": "nodej 如何实现将二进制文件与SQLite数据库之间相互转换",
      "last_reply_at": "2019-07-25T01:41:15.177Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 414,
      "create_at": "2019-07-24T09:03:33.408Z",
      "author": {
        "loginname": "spursy",
        "avatar_url": "https://avatars0.githubusercontent.com/u/11460991?v=4&s=120"
      }
    },
    {
      "id": "5d35a064b2b9222961dad2cf",
      "author_id": "5767958318c067200342491c",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>最近闲来无事，突发奇想，也顺便练练手，于是就萌生了，能否用typescript的decorator写一个Nodejs SpringMVC，然后就有了这个项目。\n该项目支持:</p>\n<ol>\n<li>依赖注入Controller ,Service</li>\n<li>注入GET/POST/PUT/DELETE/PATCH等rest方法</li>\n<li>解析rest api的参数，例如RequestParam</li>\n<li>上传文件支持Multer</li>\n<li><strong>支持在vscode里面直接debug typescript 的代码</strong></li>\n</ol>\n<p>想学习如何debug typescript代码的同学可以留意一下，真的很好用。</p>\n<p>直接上readMe的部分内容：</p>\n<h2>Installation</h2>\n<pre class=\"prettyprint language-js\"><code>npm i easy-node-ioc --save\n</code></pre><h2>Quick Start</h2>\n<p>Check out the <a href=\"https://github.com/chenkang084/easy-node-ioc/tree/master/src/test\">quick start example</a> in <code>test</code>.</p>\n<h2>Usage</h2>\n<h3>1.Create a Controller</h3>\n<pre class=\"prettyprint language-javascript\"><code>import { Controller} from &#x27;easy-node-ioc&#x27;;\n@Controller(&#x27;&#x2F;test&#x27;)\nclass TestControl {\n    ...\n}\n</code></pre><h3>2.Create a Service</h3>\n<pre class=\"prettyprint language-javascript\"><code>import { Service } from &#x27;easy-node-ioc&#x27;;\n@Service(&#x27;&#x27;)\nclass TestService {\n    ...\n}\n</code></pre><h3>3.Inject Service</h3>\n<pre class=\"prettyprint language-javascript\"><code>import { Autowired,Controller } from &#x27;easy-node-ioc&#x27;;\n@Controller(&#x27;&#x2F;test&#x27;)\nclass TestControl {\n    @Autowired\n    testService: TestService;\n    ...\n}\n</code></pre><h3>4.Define Rest API:GET,POST,PUT,DELETE,PATCH</h3>\n<pre class=\"prettyprint language-javascript\"><code>import { Autowired,Controller,GET,RequestParam } from &#x27;easy-node-ioc&#x27;;\n@Controller(&#x27;&#x2F;test&#x27;)\nclass TestControl {\n    @Autowired\n    testService: TestService;\n    @Get(&#x27;&#x2F;index&#x27;)\n    index(@RequestParam(&#x27;age&#x27;) age: number, req: Request, res: Response) {\n        console.log(&#x27;index method&#x27;);\n        this.dbService.queryDb();\n\n        res.status(200).send(this.testService.queryDb());\n    }\n    ...\n}\n</code></pre><h3>4.Define Start App</h3>\n<pre class=\"prettyprint language-javascript\"><code>import { Bootstrap, ComponentScan } from &quot;..&#x2F;&quot;;\n@ComponentScan(join(__dirname, &quot;.&#x2F;Controller.ts&quot;))\n@Bootstrap\nclass App {\n  constructor() {}\n\n  app = express();\n\n  main() {\n    const server = http.createServer(this.app);\n\n    server.listen(9001, function() {\n      console.log(&quot;Example app listening at http:&#x2F;&#x2F;%s:%s&quot;);\n    });\n  }\n}\n</code></pre><h2>How to debug</h2>\n<p>if you use vscode , just follow <code>.vscode/launch.json</code> , select <code>Launch Program</code> .<br>\nif you see <code>Example app has started.</code> in the console , then means test case start successfully .<br>\nTry to call <code>http://localhost:9001/api/test/index</code> .</p>\n<p>gitHub地址：<a href=\"https://github.com/chenkang084/easy-node-ioc\">https://github.com/chenkang084/easy-node-ioc</a></p>\n<p>说明：由于这个项目也是突发奇想，可能会存在问题。不过，目前我已经用这个包，重写了我公司内部的一个node后台项目，目前一切运行良好。\n同时，欢迎issues，如果你觉得还可以，也可以给我一个star。</p>\n</div>",
      "title": "Nodejs Spring MVC --支持直接debug ts code",
      "last_reply_at": "2019-07-25T01:07:25.440Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 1021,
      "create_at": "2019-07-22T11:39:16.277Z",
      "author": {
        "loginname": "chenkang084",
        "avatar_url": "https://avatars1.githubusercontent.com/u/16607418?v=4&s=120"
      }
    },
    {
      "id": "5b5e78f5673571454c633cea",
      "author_id": "5b56866ae740336c7bedb345",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>koa2实战项目介绍（真全栈）：</strong></p>\n<p><strong>Nodejs+koa2实战视频教程</strong>从零开始一步一步让你学会Koa基础以及用用<strong>Koa开发项目</strong>，本教程涉及 用户权限判断 、<strong>验证码</strong> 、分页、多级分类、<strong>ueditor可视化富文本编辑器</strong>、图片上传、<strong>底层DB库封装</strong>、<strong>扩展art-template的核心方法、<strong>ajax改变状态、ajax排序、以及赠送的</strong>Socket.io机器人</strong> 、Socket.io多人聊天室、<strong>Socket.io群聊</strong>、前后端分离 <strong>RESTful API Api</strong>接口、购买域名 服务器、域名备案、<strong>nginx负载均衡</strong>、<strong>域名解析部署nodejs程序</strong>、Nodejs进程管理器pm2模块、Koa操作<strong>mysql数据库</strong></p>\n<p><strong>地址：</strong> <a href=\"https://www.itying.com/goods-800.html\">Koa2实战视频教程下载地址点我</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n</div>",
      "title": "Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程",
      "last_reply_at": "2019-07-25T00:56:32.002Z",
      "good": false,
      "top": false,
      "reply_count": 81,
      "visit_count": 17428,
      "create_at": "2018-07-30T02:33:25.113Z",
      "author": {
        "loginname": "songsunli",
        "avatar_url": "https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"
      }
    },
    {
      "id": "5d33f565b2b9222961dacac2",
      "author_id": "58de5214b3e60b982d089dc3",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>egg总体来说挺好用的, 我们也内部开发了一些插件和中间件.\n但一直有这些问题有些困扰:\n1.本地调试比较麻烦: 使用的官方的vscode ts的配置, 但启动慢并且如下的断点会停两次, 总共要花将近20秒真正准备好.\n<img src=\"//static.cnodejs.org/FoQT4t9afKcXjVe_QkNldrElxYgP\" alt=\"image.png\">\n2.单进程貌似还没有正式支持吧, 这样在容器化环境里面多起了对我们来说不必要的worker等进程.\n3.我们用的ts, 有时候想直接跳过去查看egg成员的源码很不方便, 不知道有没有计划用ts重写.\n4.有些默认功能想定制还是比较头疼, 比如日志模块需要做大的修改, 文档上对此说明不详细, 需要看源码.</p>\n</div>",
      "title": "公司在用egg, 有几个问题比较困扰.",
      "last_reply_at": "2019-07-24T09:54:38.001Z",
      "good": false,
      "top": false,
      "reply_count": 20,
      "visit_count": 1657,
      "create_at": "2019-07-21T05:17:25.686Z",
      "author": {
        "loginname": "xiaozhongliu",
        "avatar_url": "https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"
      }
    },
    {
      "id": "5d37b9ffb4725a628e268425",
      "author_id": "5bf3cec8e6481c5709f5d871",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>列：const json=[{a:1,b:2},{a:2,b:1}…]; 获取数组中对象a=10001的对象，然后知道b的值。除了遍历，有没有更高效简洁的算法实现获取</p>\n</div>",
      "title": "json数组中，如何快速查询到数组中到某个对象",
      "last_reply_at": "2019-07-24T06:50:40.668Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 522,
      "create_at": "2019-07-24T01:53:03.716Z",
      "author": {
        "loginname": "tzbcf",
        "avatar_url": "https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"
      }
    },
    {
      "id": "5d37cfb39969a529571d6d2c",
      "author_id": "5cf0fa211fe902120f31b023",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h3>0. 前言</h3>\n<p>本文将手把手教你如何写出迷你版微博的一行行代码，迷你版微博包含以下功能：</p>\n<ul>\n<li>Feed 流：关注动态、所有动态</li>\n<li>发送图文动态</li>\n<li>搜索用户</li>\n<li>关注系统</li>\n<li>点赞动态</li>\n<li>个人主页</li>\n</ul>\n<p>使用到的云开发能力：</p>\n<ul>\n<li>云数据库</li>\n<li>云存储</li>\n<li>云函数</li>\n<li>云调用</li>\n</ul>\n<p>没错，几乎是所有的云开发能力。也就是说，读完这篇实战，你就相当于完全入门了云开发！</p>\n<p>咳咳，当然，实际上这里只是介绍核心逻辑和重点代码片段，完整代码建议下载查看。</p>\n<h3>1. 取得授权</h3>\n<p>作为一个社交平台，首先要做的肯定是经过用户授权，获取用户信息，小程序提供了很方便的接口：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt;\n  进入小圈圈\n&lt;&#x2F;button&gt;\n</code></pre><p>这个 <code>button</code> 有个 <code>open-type</code> 属性，这个属性是专门用来使用小程序的开放能力的，而 <code>getUserInfo</code> 则表示 <strong>获取用户信息，可以从<code>bindgetuserinfo</code>回调中获取到用户信息</strong>。</p>\n<p>于是我们可以在 wxml 里放入这个 <code>button</code> 后，在相应的 js 里写如下代码：</p>\n<pre class=\"prettyprint language-js\"><code>Page({\n  ...\n\n  getUserInfo: function(e) {\n    wx.navigateTo({\n      url: &quot;&#x2F;pages&#x2F;circle&#x2F;circle&quot;\n    })\n  },\n\n  ...\n})\n</code></pre><p>这样在成功获取到用户信息后，我们就能跳转到迷你微博页面了。</p>\n<p>需要注意，不能使用 <code>wx.authorize({scope: &quot;scope.userInfo&quot;})</code> 来获取读取用户信息的权限，因为它不会跳出授权弹窗。目前只能使用上面所述的方式实现。</p>\n<h3>2. 主页设计</h3>\n<p>社交平台的主页大同小异，主要由三个部分组成：</p>\n<ul>\n<li>Feed 流</li>\n<li>消息</li>\n<li>个人信息</li>\n</ul>\n<p>那么很容易就能想到这样的布局（注意新建一个 Page 哦，路径：<code>pages/circle/circle.wxml</code>）：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;view class=&quot;circle-container&quot;&gt;\n  &lt;view\n    style=&quot;display:{{currentPage === &#x27;main&#x27; ? &#x27;block&#x27; : &#x27;none&#x27;}}&quot;\n    class=&quot;main-area&quot;\n  &gt;\n  &lt;&#x2F;view&gt;\n\n  &lt;view\n    style=&quot;display:{{currentPage === &#x27;msg&#x27; ? &#x27;flex&#x27; : &#x27;none&#x27;}}&quot;\n    class=&quot;msg-area&quot;\n  &gt;\n  &lt;&#x2F;view&gt;\n\n  &lt;view\n    style=&quot;display:{{currentPage === &#x27;me&#x27; ? &#x27;flex&#x27; : &#x27;none&#x27;}}&quot;\n    class=&quot;me-area&quot;\n  &gt;\n  &lt;&#x2F;view&gt;\n\n  &lt;view class=&quot;footer&quot;&gt;\n    &lt;view class=&quot;footer-item&quot;&gt;\n      &lt;button\n        class=&quot;footer-btn&quot;\n        bindtap=&quot;onPageMainTap&quot;\n        style=&quot;background: {{currentPage === &#x27;main&#x27; ? &#x27;#111&#x27; : &#x27;rgba(0,0,0,0)&#x27;}}; color: {{currentPage === &#x27;main&#x27; ? &#x27;#fff&#x27; : &#x27;#000&#x27;}}&quot;\n      &gt;\n        首页\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;view&gt;\n    &lt;view class=&quot;footer-item&quot;&gt;\n      &lt;button\n        class=&quot;footer-btn&quot;\n        bindtap=&quot;onPageMsgTap&quot;\n        style=&quot;background: {{currentPage === &#x27;msg&#x27; ? &#x27;#111&#x27; : &#x27;rgba(0,0,0,0)&#x27;}}; color: {{currentPage === &#x27;msg&#x27; ? &#x27;#fff&#x27; : &#x27;#000&#x27;}}&quot;\n      &gt;\n        消息\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;view&gt;\n    &lt;view class=&quot;footer-item&quot;&gt;\n      &lt;button\n        class=&quot;footer-btn&quot;\n        bindtap=&quot;onPageMeTap&quot;\n        style=&quot;background: {{currentPage === &#x27;me&#x27; ? &#x27;#111&#x27; : &#x27;rgba(0,0,0,0)&#x27;}}; color: {{currentPage === &#x27;me&#x27; ? &#x27;#fff&#x27; : &#x27;#000&#x27;}}&quot;\n      &gt;\n        个人\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n</code></pre><p>很好理解，画面主要被分为上下两个部分：上面的部分是主要内容，下面的部分是三个 Tab 组成的 Footer。重点 WXSS 实现（完整的 WXSS 可以下载源码查看）：</p>\n<pre class=\"prettyprint language-css\"><code>.footer {\n  box-shadow: 0 0 15rpx #ccc;\n  display: flex;\n  position: fixed;\n  height: 120rpx;\n  bottom: 0;\n  width: 100%;\n  flex-direction: row;\n  justify-content: center;\n  z-index: 100;\n  background: #fff;\n}\n\n.footer-item {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  width: 33.33%;\n  color: #333;\n}\n\n.footer-item:nth-child(2) {\n  border-left: 3rpx solid #aaa;\n  border-right: 3rpx solid #aaa;\n  flex-grow: 1;\n}\n\n.footer-btn {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 0;\n  font-size: 30rpx;\n}\n</code></pre><p>核心逻辑是通过 <code>position: fixed</code> 来让 Footer 一直在下方。</p>\n<p>读者会发现有一个 <code>currentPage</code> 的 data ，这个 data 的作用其实很直观：通过判断它的值是 <code>main</code>/<code>msg</code>/<code>me</code> 中的哪一个来决定主要内容。同时，为了让首次使用的用户知道自己在哪个 Tab，Footer 中相应的 <code>button</code> 也会从白底黑字黑底白字，与另外两个 Tab 形成对比。</p>\n<p>现在我们来看看 <code>main</code> 部分的代码（在上面代码的基础上扩充）:</p>\n<pre class=\"prettyprint language-html\"><code>...\n&lt;view\n  class=&quot;main-header&quot;\n  style=&quot;display:{{currentPage === &#x27;main&#x27; ? &#x27;flex&#x27; : &#x27;none&#x27;}};max-height:{{mainHeaderMaxHeight}}&quot;\n&gt;\n  &lt;view class=&quot;group-picker-wrapper&quot;&gt;\n    &lt;picker\n      bindchange=&quot;bindGroupPickerChange&quot;\n      value=&quot;{{groupArrayIndex}}&quot;\n      range=&quot;{{groupArray}}&quot;\n      class=&quot;group-picker&quot;\n    &gt;\n      &lt;button class=&quot;group-picker-inner&quot;&gt;\n        {{groupArray[groupArrayIndex]}}\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;picker&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class=&quot;search-btn-wrapper&quot;&gt;\n    &lt;button class=&quot;search-btn&quot; bindtap=&quot;onSearchTap&quot;&gt;搜索用户&lt;&#x2F;button&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n&lt;view\n  class=&quot;main-area&quot;\n  style=&quot;display:{{currentPage === &#x27;main&#x27; ? &#x27;block&#x27; : &#x27;none&#x27;}};height: {{mainAreaHeight}};margin-top:{{mainAreaMarginTop}}&quot;\n&gt;\n  &lt;scroll-view scroll-y class=&quot;main-area-scroll&quot; bindscroll=&quot;onMainPageScroll&quot;&gt;\n    &lt;block\n      wx:for=&quot;{{pageMainData}}&quot;\n      wx:for-index=&quot;idx&quot;\n      wx:for-item=&quot;itemName&quot;\n      wx:key=&quot;_id&quot;\n    &gt;\n      &lt;post-item is=&quot;post-item&quot; data=&quot;{{itemName}}&quot; class=&quot;post-item-wrapper&quot; &#x2F;&gt;\n    &lt;&#x2F;block&gt;\n    &lt;view wx:if=&quot;{{pageMainData.length === 0}}&quot; class=&quot;item-placeholder&quot;\n      &gt;无数据&lt;&#x2F;view\n    &gt;\n  &lt;&#x2F;scroll-view&gt;\n  &lt;button\n    class=&quot;add-poster-btn&quot;\n    bindtap=&quot;onAddPosterTap&quot;\n    hover-class=&quot;add-poster-btn-hover&quot;\n    style=&quot;bottom:{{addPosterBtnBottom}}&quot;\n  &gt;\n    +\n  &lt;&#x2F;button&gt;\n&lt;&#x2F;view&gt;\n...\n</code></pre><p>这里用到了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html\">列表渲染</a> 和 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html\">条件渲染</a>，还不清楚的可以点击进去学习一下。</p>\n<p>可以看到，相比之前的代码，我添加一个 header，同时 <code>main-area</code> 的内部也新增了一个 <code>scroll-view</code>（用于展示 Feed 流） 和一个 <code>button</code>（用于编辑新迷你微博）。header 的功能很简单：左侧区域是一个 <code>picker</code>，可以选择查看的动态类型（目前有 <em>关注动态</em> 和 <em>所有动态</em> 两种）；右侧区域是一个按钮，点击后可以跳转到搜索页面，这两个功能我们先放一下，先继续看 <code>main-area</code> 的新增内容。</p>\n<p><code>main-area</code> 里的 <code>scroll-view</code> 是一个可监听滚动事件的列表，其中监听事件的实现：</p>\n<pre class=\"prettyprint language-js\"><code>data: {\n  ...\n  addPosterBtnBottom: &quot;190rpx&quot;,\n  mainHeaderMaxHeight: &quot;80rpx&quot;,\n  mainAreaHeight: &quot;calc(100vh - 200rpx)&quot;,\n  mainAreaMarginTop: &quot;80rpx&quot;,\n},\nonMainPageScroll: function(e) {\n  if (e.detail.deltaY &lt; 0) {\n    this.setData({\n      addPosterBtnBottom: &quot;-190rpx&quot;,\n      mainHeaderMaxHeight: &quot;0&quot;,\n      mainAreaHeight: &quot;calc(100vh - 120rpx)&quot;,\n      mainAreaMarginTop: &quot;0rpx&quot;\n    })\n  } else {\n    this.setData({\n      addPosterBtnBottom: &quot;190rpx&quot;,\n      mainHeaderMaxHeight: &quot;80rpx&quot;,\n      mainAreaHeight: &quot;calc(100vh - 200rpx)&quot;,\n      mainAreaMarginTop: &quot;80rpx&quot;\n    })\n  }\n},\n...\n</code></pre><p>结合 wxml 可以知道，当页面向下滑动 （deltaY &lt; 0） 时，header 和 <code>button</code> 会 “突然消失”，反之它们则会 “突然出现”。为了视觉上有更好地过渡，我们可以在 WXSS 中使用 <code>transition</code> ：</p>\n<pre class=\"prettyprint language-css\"><code>...\n.main-area {\n  position: relative;\n  flex-grow: 1;\n  overflow: auto;\n  z-index: 1;\n  transition: height 0.3s, margin-top 0.3s;\n}\n.main-header {\n  position: fixed;\n  width: 100%;\n  height: 80rpx;\n  background: #fff;\n  top: 0;\n  left: 0;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  z-index: 100;\n  border-bottom: 3rpx solid #aaa;\n  transition: max-height 0.3s;\n  overflow: hidden;\n}\n.add-poster-btn {\n  position: fixed;\n  right: 60rpx;\n  box-shadow: 5rpx 5rpx 10rpx #aaa;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: #333;\n  padding-bottom: 10rpx;\n  text-align: center;\n  border-radius: 50%;\n  font-size: 60rpx;\n  width: 100rpx;\n  height: 100rpx;\n  transition: bottom 0.3s;\n  background: #fff;\n  z-index: 1;\n}\n...\n</code></pre><h3>3. Feed 流</h3>\n<h4>3.1 post-item</h4>\n<p>前面提到，<code>scroll-view</code> 的内容是 Feed 流，那么首先就要想到使用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html\">列表渲染</a>。而且，为了方便在个人主页复用，列表渲染中的每一个 item 都要抽象出来。这时就要使用小程序中的 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/\">Custom-Component</a> 功能了。</p>\n<p>新建一个名为 <code>post-item</code> 的 <code>Component</code>，其中 wxml 的实现（路径：<code>pages/circle/component/post-item/post-item.js</code>）：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;view\n  class=&quot;post-item&quot;\n  hover-class=&quot;post-item-hover&quot;\n  bindlongpress=&quot;onItemLongTap&quot;\n  bindtap=&quot;onItemTap&quot;\n&gt;\n  &lt;view class=&quot;post-title&quot;&gt;\n    &lt;view class=&quot;author&quot; hover-class=&quot;author-hover&quot; catchtap=&quot;onAuthorTap&quot;\n      &gt;{{data.author}}&lt;&#x2F;view\n    &gt;\n    &lt;view class=&quot;date&quot;&gt;{{data.formatDate}}&lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class=&quot;msg-wrapper&quot;&gt;\n    &lt;text class=&quot;msg&quot;&gt;{{data.msg}}&lt;&#x2F;text&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class=&quot;image-outer&quot; wx:if=&quot;{{data.photoId !== &#x27;&#x27;}}&quot; catchtap=&quot;onImgTap&quot;&gt;\n    &lt;image-wrapper is=&quot;image-wrapper&quot; src=&quot;{{data.photoId}}&quot; &#x2F;&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n</code></pre><p>可见，一个 <code>poster-item</code> 最主要有以下信息：</p>\n<ul>\n<li>作者名</li>\n<li>发送时间</li>\n<li>文本内容</li>\n<li>图片内容</li>\n</ul>\n<p>其中，图片内容因为是可选的，所以使用了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html\">条件渲染</a>，这会在没有图片信息时不让图片显示区域占用屏幕空间。另外，图片内容主要是由 <code>image-wrapper</code> 组成，它也是一个 <code>Custom-Component</code>，主要功能是：</p>\n<ul>\n<li>强制长宽 1:1 裁剪显示图片</li>\n<li>点击查看大图</li>\n<li>未加载完成时显示 加载中</li>\n</ul>\n<p>具体代码这里就不展示了，比较简单，读者可以在 <code>component/image-wrapper</code> 里找到。</p>\n<p>回过头看 <code>main-area</code> 的其他新增部分，细心的读者会发现有这么一句：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;view wx:if=&quot;{{pageMainData.length === 0}}&quot; class=&quot;item-placeholder&quot;\n  &gt;无数据&lt;&#x2F;view\n&gt;\n</code></pre><p>这会在 Feed 流暂时没有获取到数据时给用户一个提示。</p>\n<h4>3.2 collections: poster、poster_users</h4>\n<p>展示 Feed 流的部分已经编写完毕，现在就差实际数据了。根据上一小节 <code>poster-item</code> 的主要信息，我们可以初步推断出一条迷你微博在 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#%E6%95%B0%E6%8D%AE%E5%BA%93\">云数据库</a> 的 collection <code>poster</code> 里是这样存储的：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;username&quot;: &quot;Tester&quot;,\n  &quot;date&quot;: &quot;2019-07-22 12:00:00&quot;,\n  &quot;text&quot;: &quot;Ceshiwenben&quot;,\n  &quot;photo&quot;: &quot;xxx&quot;\n}\n</code></pre><p>先来看 <code>username</code>。由于社交平台一般不会限制用户的昵称，所以如果每条迷你微博都存储昵称，那将来每次用户修改一次昵称，就要遍历数据库把所有迷你微博项都改一遍，相当耗费时间，所以我们不如存储一个 <code>userId</code>，并另外把 id 和 昵称 的对应关系存在另一个叫 <code>poster_users</code> 的 collection 里。</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;userId&quot;: &quot;xxx&quot;,\n  &quot;name&quot;: &quot;Tester&quot;,\n  ...（其他用户信息）\n}\n</code></pre><p><code>userId</code> 从哪里拿呢？当然是通过之前已经授权的获取用户信息接口拿到了，详细操作之后会说到。</p>\n<p>接下来是 <code>date</code>，这里最好是服务器时间（因为客户端传过来的时间可能会有误差），而云开发文档里也有提供相应的接口：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/database/db.serverDate.html#db.serverDate\">serverDate</a>。这个数据可以直接被 <code>new Date()</code> 使用，可以理解为一个 UTC 时间。</p>\n<p><code>text</code> 即文本信息，直接存储即可。</p>\n<p><code>photo</code> 则表示附图数据，但是限于小程序 <code>image</code> 元素的实现，想要显示一张图片，要么提供该图片的 url，要么提供该图片在 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#%E5%AD%98%E5%82%A8\">云存储</a> 的 id，所以这里最佳的实践是：先把图片上传到云存储里，然后把回调里的文件 id 作为数据存储。</p>\n<p>综上所述，最后 <code>poster</code> 每一项的数据结构如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;authorId&quot;: &quot;xxx&quot;,\n  &quot;date&quot;: &quot;utc-format-date&quot;,\n  &quot;text&quot;: &quot;Ceshiwenben&quot;,\n  &quot;photoId&quot;: &quot;yyy&quot;\n}\n</code></pre><p>确定数据结构后，我们就可以开始往 collection 添加数据了。但是，在此之前，我们还缺少一个重要步骤。</p>\n<h4>3.3 用户信息录入 与 云数据库</h4>\n<p>没错，我们还没有在 <code>poster_users</code> 里添加一条新用户的信息。这个步骤一般在 <code>pages/circle/circle</code> 页面首次加载时判断即可：</p>\n<pre class=\"prettyprint language-js\"><code>getUserId: function(cb) {\n  let that = this\n  var value = this.data.userId || wx.getStorageSync(&quot;userId&quot;)\n  if (value) {\n    if (cb) {\n      cb(value)\n    }\n    return value\n  }\n  wx.getSetting({\n    success(res) {\n      if (res.authSetting[&quot;scope.userInfo&quot;]) {\n        wx.getUserInfo({\n          withCredentials: true,\n          success: function(userData) {\n            wx.setStorageSync(&quot;userId&quot;, userData.signature)\n            that.setData({\n              userId: userData.signature\n            })\n            db.collection(&quot;poster_users&quot;)\n              .where({\n                userId: userData.signature\n              })\n              .get()\n              .then(searchResult =&gt; {\n                if (searchResult.data.length === 0) {\n                  wx.showToast({\n                    title: &quot;新用户录入中&quot;\n                  })\n                  db.collection(&quot;poster_users&quot;)\n                    .add({\n                      data: {\n                        userId: userData.signature,\n                        date: db.serverDate(),\n                        name: userData.userInfo.nickName,\n                        gender: userData.userInfo.gender\n                      }\n                    })\n                    .then(res =&gt; {\n                      console.log(res)\n                      if (res.errMsg === &quot;collection.add:ok&quot;) {\n                        wx.showToast({\n                          title: &quot;录入完成&quot;\n                        })\n                        if (cb) cb()\n                      }\n                    })\n                    .catch(err =&gt; {\n                      wx.showToast({\n                        title: &quot;录入失败，请稍后重试&quot;,\n                        image: &quot;&#x2F;images&#x2F;error.png&quot;\n                      })\n                      wx.navigateTo({\n                        url: &quot;&#x2F;pages&#x2F;index&#x2F;index&quot;\n                      })\n                    })\n                } else {\n                  if (cb) cb()\n                }\n              })\n          }\n        })\n      } else {\n        wx.showToast({\n          title: &quot;登陆失效，请重新授权登陆&quot;,\n          image: &quot;&#x2F;images&#x2F;error.png&quot;\n        })\n        wx.navigateTo({\n          url: &quot;&#x2F;pages&#x2F;index&#x2F;index&quot;\n        })\n      }\n    }\n  })\n}\n</code></pre><p>代码实现比较复杂，整体思路是这样的：</p>\n<ol>\n<li>判断是否已存储了 <code>userId</code>，如果有直接返回并调用回调函数，如果没有继续 2</li>\n<li>通过 <code>wx.getSetting</code> 获取当前设置信息</li>\n<li>如果返回里有 <code>res.authSetting[&quot;scope.userInfo&quot;]</code> 说明已经授权读取用户信息，继续 3，没有授权的话就跳转回首页重新授权</li>\n<li>调用 <code>wx.getUserInfo</code> 获取用户信息，成功后提取出 <code>signature</code>（这是每个微信用户的唯一签名），并调用 <code>wx.setStorageSync</code> 将其缓存</li>\n<li>调用 <code>db.collection().where().get()</code> ，判断返回的数据是否是空数组，如果不是说明该用户已经录入（注意 <code>where()</code> 中的筛选条件），如果是说明该用户是新用户，继续 5</li>\n<li>提示新用户录入中，同时调用 <code>db.collection().add()</code> 来添加用户信息，最后通过回调判断是否录入成功，并提示用户</li>\n</ol>\n<p>不知不觉我们就使用了云开发中的 云数据库 功能，紧接着我们就要开始使用 云存储 和 云函数了！</p>\n<h4>3.4 addPoster 与 云存储</h4>\n<p>发送新的迷你微博，需要一个编辑新迷你微博的界面，路径我定为 <code>pages/circle/add-poster/add-poster</code>：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;view class=&quot;app-poster-container&quot;&gt;\n  &lt;view class=&quot;body&quot;&gt;\n    &lt;view class=&quot;text-area-wrapper&quot;&gt;\n      &lt;textarea bindinput=&quot;bindTextInput&quot; placeholder=&quot;在此填写&quot; value=&quot;{{text}}&quot; auto-focus=&quot;true&quot; &#x2F;&gt;\n      &lt;view class=&quot;text-area-footer&quot;&gt;\n        &lt;text&gt;{{remainLen}}&#x2F;140&lt;&#x2F;text&gt;\n      &lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n    &lt;view bindtap=&quot;onImageTap&quot; class=&quot;image-area&quot;&gt;\n      &lt;view class=&quot;image-outer&quot;&gt;\n        &lt;image-wrapper is=&quot;image-wrapper&quot; src=&quot;{{imageSrc}}&quot; placeholder=&quot;选择图片上传&quot; &#x2F;&gt;\n      &lt;&#x2F;view&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n  &lt;view class=&quot;footer&quot;&gt;\n    &lt;button class=&quot;footer-btn&quot; bindtap=&quot;onSendTap&quot;&gt;发送&lt;&#x2F;button&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n</code></pre><p>wxml 的代码很好理解：<code>textarea</code> 显示编辑文本，<code>image-wrapper</code> 显示需要上传的图片，最下面是一个发送的 <code>button</code>。其中，图片编辑区域的 <code>bindtap</code> 事件实现：</p>\n<pre class=\"prettyprint language-js\"><code>onImageTap: function() {\n  let that = this\n  wx.chooseImage({\n    count: 1,\n    success: function(res) {\n      const tempFilePaths = res.tempFilePaths\n      that.setData({\n        imageSrc: tempFilePaths[0]\n      })\n    }\n  })\n}\n</code></pre><p>直接通过 <code>wx.chooseImage</code> 官方 API 获取本地图片的临时路径即可。而当发送按钮点击后，会有如下代码被执行：</p>\n<pre class=\"prettyprint language-js\"><code>onSendTap: function() {\n  if (this.data.text === &quot;&quot; &amp;&amp; this.data.imageSrc === &quot;&quot;) {\n    wx.showModal({\n      title: &quot;错误&quot;,\n      content: &quot;不能发送空内容&quot;,\n      showCancel: false,\n      confirmText: &quot;好的&quot;\n    })\n    return\n  }\n  const that = this\n  wx.showLoading({\n    title: &quot;发送中&quot;,\n    mask: true\n  })\n  const imageSrc = this.data.imageSrc\n  if (imageSrc !== &quot;&quot;) {\n    const finalPath = imageSrc.replace(&quot;&#x2F;&#x2F;&quot;, &quot;&#x2F;&quot;).replace(&quot;:&quot;, &quot;&quot;)\n    wx.cloud\n      .uploadFile({\n        cloudPath: finalPath,\n        filePath: imageSrc &#x2F;&#x2F; 文件路径\n      })\n      .then(res =&gt; {\n        that.sendToDb(res.fileID)\n      })\n      .catch(error =&gt; {\n        that.onSendFail()\n      })\n  } else {\n    that.sendToDb()\n  }\n},\nsendToDb: function(fileId = &quot;&quot;) {\n  const that = this\n  const posterData = {\n    authorId: that.data.userId,\n    msg: that.data.text,\n    photoId: fileId,\n    date: db.serverDate()\n  }\n  db.collection(&quot;poster&quot;)\n    .add({\n      data: {\n        ...posterData\n      }\n    })\n    .then(res =&gt; {\n      wx.showToast({\n        title: &quot;发送成功&quot;\n      })\n      wx.navigateBack({\n        delta: 1\n      })\n    })\n    .catch(error =&gt; {\n      that.onSendFail()\n    })\n    .finally(wx.hideLoading())\n}\n</code></pre><ol>\n<li>首先判断文本和图片内容是否都为空，如果是则不执行发送，如果不是继续 2</li>\n<li>提示发送中，上传图片到云存储，注意需要将图片中的临时 url 的一些特殊字符组合替换一下，原因见 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/storage/naming.html\">文件名命名限制</a></li>\n<li>上传成功后，调用 <code>db.collection().add()</code>，发送成功后退回上一页（即首页），如果失败则执行 <code>onSendFail</code> 函数，后者见源码，逻辑较简单这里不赘述</li>\n</ol>\n<p>于是，我们就这样创建了第一条迷你微博。接下来就让它在 Feed 流中显示吧！</p>\n<h4>3.5 云函数 getMainPageData</h4>\n<p>这个函数的主要作用如前所述，就是通过处理云数据库中的数据，将最终数据返回给客户端，后者将数据可视化给用户。我们先做一个初步版本，因为现在 <code>poster_users</code> 中只有一条数据，所以仅先展示自己的迷你微博。<code>getMainPageData</code> 云函数代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 云函数入口文件\nconst cloud = require(&quot;wx-server-sdk&quot;)\ncloud.init()\nconst db = cloud.database()\n\n&#x2F;&#x2F; 云函数入口函数\nexports.main = async (event, context, cb) =&gt; {\n  &#x2F;&#x2F; 通过 event 获取入参\n  const userId = event.userId\n  let followingResult\n  let users\n  &#x2F;&#x2F; idNameMap 负责存储 userId 和 name 的映射关系\n  let idNameMap = {}\n  let followingIds = []\n  &#x2F;&#x2F; 获取用户信息\n  followingResult = await db\n      .collection(&quot;poster_users&quot;)\n      .where({\n        userId: userId\n      })\n      .get()\n    users = followingResult.data\n    followingIds = users.map(u =&gt; {\n      return u.userId\n    })\n  users.map(u =&gt; {\n    idNameMap[u.userId] = u.name\n  })\n  &#x2F;&#x2F; 获取动态\n  const postResult = await db\n    .collection(&quot;poster&quot;)\n    .orderBy(&quot;date&quot;, &quot;desc&quot;)\n    .where({\n      &#x2F;&#x2F; 通过高级筛选功能筛选出符合条件的 userId\n      authorId: db.command.in(followingIds)\n    })\n    .get()\n  const postData = postResult.data\n  &#x2F;&#x2F; 向返回的数据添加 存储用户昵称的 author 属性、存储格式化后的时间的 formatDate 属性\n  postData.map(p =&gt; {\n    p.author = idNameMap[p.authorId]\n    p.formatDate = new Date(p.date).toLocaleDateString(&quot;zh-Hans&quot;, options)\n  })\n  return postData\n}\n</code></pre><p>最后在 <code>pages/circle/circle.js</code> 里补充云调用：</p>\n<pre class=\"prettyprint language-js\"><code>getMainPageData: function(userId) {\n  const that = this\n  wx.cloud\n    .callFunction({\n      name: &quot;getMainPageData&quot;,\n      data: {\n        userId: userId,\n        isEveryOne: that.data.groupArrayIndex === 0 ? false : true\n      }\n    })\n    .then(res =&gt; {\n      that.setData({\n        pageMainData: res.result,\n        pageMainLoaded: true\n      })\n    })\n    .catch(err =&gt; {\n      wx.showToast({\n        title: &quot;获取动态失败&quot;,\n        image: &quot;&#x2F;images&#x2F;error.png&quot;\n      })\n      wx.hideLoading()\n    })\n}\n</code></pre><p>即可展示 Feed 流数据给用户。</p>\n<p>之后，<code>getMainPageData</code> 还会根据使用场景的不同，新增了查询所有用户动态、查询关注用户动态的功能，但是原理是一样的，看源码可以轻易理解，后续就不再说明。</p>\n<h3>4. 关注系统</h3>\n<p>上一节中我们一口气把云开发中的大部分主要功能：云数据库、云存储、云函数、云调用都用了一遍，接下来其他功能的实现也基本都依赖它们。</p>\n<h4>4.1 poster_user_follows</h4>\n<p>首先我们需要建一个新的 collection <code>poster_user_follows</code>，其中的每一项数据的数据结构如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;followerId&quot;: &quot;xxx&quot;,\n  &quot;followingId&quot;: &quot;xxx&quot;\n}\n</code></pre><p>很简单，<code>followerId</code> 表示关注人，<code>followingId</code> 表示被关注人。</p>\n<h4>4.2 user-data 页面</h4>\n<p>关注或者取消关注需要进入他人的个人主页操作，我们在 <code>pages/circle/user-data/user-data.wxml</code> 中放一个 <code>user-info</code> 的自定义组件，然后新建该组件编辑：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;view class=&quot;user-info&quot;&gt;\n  &lt;view class=&quot;info-item&quot; hover-class=&quot;info-item-hover&quot;&gt;用户名: {{userName}}&lt;&#x2F;view&gt;\n  &lt;view class=&quot;info-item&quot; hover-class=&quot;info-item-hover&quot; bindtap=&quot;onPosterCountTap&quot;&gt;动态数: {{posterCount}}&lt;&#x2F;view&gt;\n  &lt;view class=&quot;info-item&quot; hover-class=&quot;info-item-hover&quot; bindtap=&quot;onFollowingCountTap&quot;&gt;关注数: {{followingCount}}&lt;&#x2F;view&gt;\n  &lt;view class=&quot;info-item&quot; hover-class=&quot;info-item-hover&quot; bindtap=&quot;onFollowerCountTap&quot;&gt;粉丝数: {{followerCount}}&lt;&#x2F;view&gt;\n  &lt;view class=&quot;info-item&quot; hover-class=&quot;info-item-hover&quot; wx:if=&quot;{{originId &amp;&amp; originId !== &#x27;&#x27; &amp;&amp; originId !== userId}}&quot;&gt;&lt;button bindtap=&quot;onFollowTap&quot;&gt;{{followText}}&lt;&#x2F;button&gt;&lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n</code></pre><p>这里注意条件渲染的 <code>button</code>：如果当前访问个人主页的用户 id （originId） 和 被访问的用户 id （userId）的值是相等的话，这个按钮就不会被渲染（自己不能关注/取消关注自己）。</p>\n<p>我们重点看下 <code>onFollowTap</code> 的实现：</p>\n<pre class=\"prettyprint language-js\"><code>onFollowTap: function() {\n  const that = this\n  &#x2F;&#x2F; 判断当前关注状态\n  if (this.data.isFollow) {\n    wx.showLoading({\n      title: &quot;操作中&quot;,\n      mask: true\n    })\n    wx.cloud\n      .callFunction({\n        name: &quot;cancelFollowing&quot;,\n        data: {\n          followerId: this.properties.originId,\n          followingId: this.properties.userId\n        }\n      })\n      .then(res =&gt; {\n        wx.showToast({\n          title: &quot;取消关注成功&quot;\n        })\n        that.setData({\n          isFollow: false,\n          followText: &quot;关注&quot;\n        })\n      })\n      .catch(error =&gt; {\n        wx.showToast({\n          title: &quot;取消关注失败&quot;,\n          image: &quot;&#x2F;images&#x2F;error.png&quot;\n        })\n      })\n      .finally(wx.hideLoading())\n  } else if (this.data.isFollow !== undefined) {\n    wx.showLoading({\n      title: &quot;操作中&quot;,\n      mask: true\n    })\n    const data = {\n      followerId: this.properties.originId,\n      followingId: this.properties.userId\n    }\n    db.collection(&quot;poster_user_follows&quot;)\n      .add({\n        data: {\n          ...data\n        }\n      })\n      .then(res =&gt; {\n        wx.showToast({\n          title: &quot;关注成功&quot;\n        })\n        that.setData({\n          isFollow: true,\n          followText: &quot;取消关注&quot;\n        })\n      })\n      .catch(error =&gt; {\n        wx.showToast({\n          title: &quot;关注失败&quot;,\n          image: &quot;&#x2F;images&#x2F;error.png&quot;\n        })\n      })\n      .finally(wx.hideLoading())\n    }\n  }\n}\n</code></pre><p>这里读者可能会有疑问：为什么关注的时候直接调用 <code>db.collection().add()</code> 即可，而取消关注却要调用云函数呢？这里涉及到云数据库的设计问题：删除多个数据的操作，或者说删除使用 <code>where</code> 筛选的数据，只能在服务端执行。如果确实想在客户端删除，则在查询用户关系时，将唯一标识数据的 <code>_id</code> 用 <code>setData</code> 存下来，之后再使用 <code>db.collection().doc(_id).delete()</code> 删除即可。这两种实现方式读者可自行选择。当然，还有一种实现是不实际删除数据，只是加个 <code>isDelete</code> 字段标记一下。</p>\n<p>查询用户关系的实现很简单，云函数的实现方式如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 云函数入口文件\nconst cloud = require(&#x27;wx-server-sdk&#x27;)\ncloud.init()\nconst db = cloud.database()\n\n&#x2F;&#x2F; 云函数入口函数\nexports.main = async(event, context) =&gt; {\n  const followingResult = await db.collection(&quot;poster_user_follows&quot;)\n    .where({\n      followingId: event.followingId,\n      followerId: event.followerId\n    }).get()\n  return followingResult\n}\n</code></pre><p>客户端只要检查返回的数据长度是否大于 0 即可。</p>\n<p>另外附上 <code>user-data</code> 页面其他数据的获取云函数实现：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 云函数入口文件\nconst cloud = require(&quot;wx-server-sdk&quot;)\ncloud.init()\nconst db = cloud.database()\n\nasync function getPosterCount(userId) {\n  return {\n    value: (await db.collection(&quot;poster&quot;).where({\n      authorId: userId\n    }).count()).total,\n    key: &quot;posterCount&quot;\n  }\n}\n\nasync function getFollowingCount(userId) {\n  return {\n    value: (await db.collection(&quot;poster_user_follows&quot;).where({\n      followerId: userId\n    }).count()).total,\n    key: &quot;followingCount&quot;\n  }\n}\n\nasync function getFollowerCount(userId) {\n  return {\n    value: (await db.collection(&quot;poster_user_follows&quot;).where({\n      followingId: userId\n    }).count()).total,\n    key: &quot;followerCount&quot;\n  }\n}\n\n\nasync function getUserName(userId) {\n  return {\n    value: (await db.collection(&quot;poster_users&quot;).where({\n      userId: userId\n    }).get()).data[0].name,\n    key: &quot;userName&quot;\n  }\n}\n\n&#x2F;&#x2F; 云函数入口函数\nexports.main = async (event, context) =&gt; {\n  const userId = event.userId\n  const tasks = []\n  tasks.push(getPosterCount(userId))\n  tasks.push(getFollowerCount(userId))\n  tasks.push(getFollowingCount(userId))\n  tasks.push(getUserName(userId))\n  const allData = await Promise.all(tasks)\n  const finalData = {}\n  allData.map(d =&gt; {\n    finalData[d.key] = d.value\n  })\n  return finalData\n}\n</code></pre><p>很好理解，客户端获取返回后直接使用即可。</p>\n<h3>5. 搜索页面</h3>\n<p>这部分其实很好实现。关键的搜索函数实现如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 云函数入口文件\nconst cloud = require(&#x27;wx-server-sdk&#x27;)\ncloud.init()\nconst db = cloud.database()\n\nconst MAX_LIMIT = 100\nasync function getDbData(dbName, whereObj) {\n  const totalCountsData = await db.collection(dbName).where(whereObj).count()\n  const total = totalCountsData.total\n  const batch = Math.ceil(total &#x2F; 100)\n  const tasks = []\n  for (let i = 0; i &lt; batch; i++) {\n    const promise = db\n      .collection(dbName)\n      .where(whereObj)\n      .skip(i * MAX_LIMIT)\n      .limit(MAX_LIMIT)\n      .get()\n    tasks.push(promise)\n  }\n  const rrr = await Promise.all(tasks)\n  if (rrr.length !== 0) {\n    return rrr.reduce((acc, cur) =&gt; {\n      return {\n        data: acc.data.concat(cur.data),\n        errMsg: acc.errMsg\n      }\n    })\n  } else {\n    return {\n      data: [],\n      errMsg: &quot;empty&quot;\n    }\n  }\n}\n\n&#x2F;&#x2F; 云函数入口函数\nexports.main = async (event, context) =&gt; {\n  const text = event.text\n  const data = await getDbData(&quot;poster_users&quot;, {\n    name: {\n      $regex: text\n    }\n  })\n  return data\n}\n</code></pre><p>这里参考了官网所推荐的分页检索数据库数据的实现（因为搜索结果可能有很多），筛选条件则是正则模糊匹配关键字。</p>\n<p>搜索页面的源码路径是 <code>pages/circle/search-user/search-user</code>，实现了点击搜索结果项跳转到对应项的用户的 <code>user-data</code> 页面，建议直接阅读源码理解。</p>\n<h3>6. 其他扩展</h3>\n<h4>6.1 poster_likes 与 点赞</h4>\n<p>由于转发、评论、点赞的原理基本相同，所以这里只介绍点赞功能如何编写，另外两个功能读者可以自行实现。</p>\n<p>毫无疑问我们需要新建一个 collection <code>poster_likes</code>，其中每一项的数据结构如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;posterId&quot;: &quot;xxx&quot;,\n  &quot;likeId&quot;: &quot;xxx&quot;\n}\n</code></pre><p>这里的 <code>posterId</code> 就是 <code>poster</code> collection 里每条记录的 <code>_id</code> 值，<code>likeId</code> 就是 <code>poster_users</code> 里的 <code>userId</code> 了。</p>\n<p>然后我们扩展一下 <code>poster-item</code> 的实现：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;view class=&quot;post-item&quot; hover-class=&quot;post-item-hover&quot; bindlongpress=&quot;onItemLongTap&quot; bindtap=&quot;onItemTap&quot;&gt;\n  ...\n  &lt;view class=&quot;interact-area&quot;&gt;\n    &lt;view class=&quot;interact-item&quot;&gt;\n      &lt;button class=&quot;interact-btn&quot; catchtap=&quot;onLikeTap&quot; style=&quot;color:{{liked ? &#x27;#55aaff&#x27; : &#x27;#000&#x27;}}&quot;&gt;赞 {{likeCount}}&lt;&#x2F;button&gt;\n    &lt;&#x2F;view&gt;\n  &lt;&#x2F;view&gt;\n&lt;&#x2F;view&gt;\n</code></pre><p>即，新增一个 <code>interact-area</code>，其中 <code>onLikeTap</code> 实现如下：</p>\n<pre class=\"prettyprint language-js\"><code>onLikeTap: function() {\n  if (!this.properties.originId) return\n  const that = this\n  if (this.data.liked) {\n    wx.showLoading({\n      title: &quot;操作中&quot;,\n      mask: true\n    })\n    wx.cloud\n      .callFunction({\n        name: &quot;cancelLiked&quot;,\n        data: {\n          posterId: this.properties.data._id,\n          likeId: this.properties.originId\n        }\n      })\n      .then(res =&gt; {\n        wx.showToast({\n          title: &quot;取消成功&quot;\n        })\n        that.refreshLike()\n        that.triggerEvent(&#x27;likeEvent&#x27;);\n      })\n      .catch(error =&gt; {\n        wx.showToast({\n          title: &quot;取消失败&quot;,\n          image: &quot;&#x2F;images&#x2F;error.png&quot;\n        })\n      })\n      .finally(wx.hideLoading())\n  } else {\n    wx.showLoading({\n      title: &quot;操作中&quot;,\n      mask: true\n    })\n    db.collection(&quot;poster_likes&quot;).add({\n        data: {\n          posterId: this.properties.data._id,\n          likeId: this.properties.originId\n        }\n      }).then(res =&gt; {\n        wx.showToast({\n          title: &quot;已赞&quot;\n        })\n        that.refreshLike()\n        that.triggerEvent(&#x27;likeEvent&#x27;);\n      })\n      .catch(error =&gt; {\n        wx.showToast({\n          title: &quot;赞失败&quot;,\n          image: &quot;&#x2F;images&#x2F;error.png&quot;\n        })\n      })\n      .finally(wx.hideLoading())\n  }\n\n}\n</code></pre><p>细心的读者会发现这和关注功能原理几乎是一样的。</p>\n<h4>6.2 数据刷新</h4>\n<p>我们可以使用很多方式让主页面刷新数据：</p>\n<pre class=\"prettyprint language-js\"><code>onShow: function() {\n  wx.showLoading({\n    title: &quot;加载中&quot;,\n    mask: true\n  })\n  const that = this\n  function cb(userId) {\n    that.refreshMainPageData(userId)\n    that.refreshMePageData(userId)\n  }\n  this.getUserId(cb)\n}\n</code></pre><p>第一种是利用 <code>onShow</code> 方法：它会在页面每次从后台转到前台展示时调用，这个时候我们就能刷新页面数据（包括 Feed 流和个人信息）。但是这个时候用户信息可能会丢失，所以我们需要在 <code>getUserId</code> 里判断，并将刷新数据的函数们整合起来，作为回调函数。</p>\n<p>第二种是让用户手动刷新：</p>\n<pre class=\"prettyprint language-js\"><code>onPageMainTap: function() {\n  if (this.data.currentPage === &quot;main&quot;) {\n    this.refreshMainPageData()\n  }\n  this.setData({\n    currentPage: &quot;main&quot;\n  })\n}\n</code></pre><p>如图所示，当目前页面是 Feed 流时，如果再次点击 首页 Tab，就会强制刷新数据。</p>\n<p>第三种是关联数据变更触发刷新，比如动态类型选择、删除了一条动态以后触发数据的刷新。这种可以直接看源码学习。</p>\n<h4>6.3 首次加载等待</h4>\n<p>当用户第一次进入主页面时，我们如果想在 Feed 流和个人信息都加载好了再允许用户操作，应该如何实现？</p>\n<p>如果是类似 Vue 或者 React 的框架，我们很容易就能想到属性监控，如 <code>watch</code>、<code>useEffect</code> 等等，但是小程序目前 <code>Page</code> 并没有提供属性监控功能，怎么办？</p>\n<p>除了自己实现，还有一个方法就是利用 <code>Component</code> 的 <code>observers</code>，它和上面提到的属性监控功能差不多。虽然官网文档对其说明比较少，但摸索了一番还是能用来监控的。</p>\n<p>首先我们来新建一个 <code>Component</code> 叫 <code>abstract-load</code>，具体实现如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; pages&#x2F;circle&#x2F;component&#x2F;abstract-load.js\nComponent({\n  properties: {\n    pageMainLoaded: {\n      type: Boolean,\n      value: false\n    },\n    pageMeLoaded: {\n      type: Boolean,\n      value: false\n    }\n  },\n  observers: {\n    &quot;pageMainLoaded, pageMeLoaded&quot;: function (pageMainLoaded, pageMeLoaded) {\n      if (pageMainLoaded &amp;&amp; pageMeLoaded) {\n        this.triggerEvent(&quot;allLoadEvent&quot;)\n      }\n    }\n  }\n})\n</code></pre><p>然后在 <code>pages/circle/circle.wxml</code> 中添加一行：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;abstract-load is=&quot;abstract-load&quot; pageMainLoaded=&quot;{{pageMainLoaded}}&quot; pageMeLoaded=&quot;{{pageMeLoaded}}&quot; bind:allLoadEvent=&quot;onAllLoad&quot; &#x2F;&gt;\n</code></pre><p>最后实现 <code>onAllLoad</code> 函数即可。</p>\n<p>另外，像这种没有实际展示数据的 <code>Component</code>，建议在项目中都用 <code>abstract</code> 开头来命名。</p>\n<h4>6.4 scroll-view 在 iOS 的 bug</h4>\n<p>如果读者使用 iOS 系统调试这个小程序，可能会发现 Feed 流比较短的时候，滚动 <code>scroll-view</code> header 和 <code>button</code> 会有鬼畜的上下抖动现象，这是因为 iOS 自己实现的 WebView 对于滚动视图有回弹的效果，而该效果也会触发滚动事件。</p>\n<p>对于这个 bug，<a href=\"https://developers.weixin.qq.com/community/develop/doc/00064a122e01782f0d583fc0151c00\">官方人员也表示暂时无法修复</a>，只能先忍一忍了。</p>\n<h4>6.5 关于消息 Tab</h4>\n<p>读者可能会疑惑我为什么没有讲解消息 Tab 以及消息提醒的实现。首先是因为源码没有这个实现，其次是我觉得目前云开发所提供的能力实现主动提醒比较麻烦（除了轮询想不到其他办法）。</p>\n<p>希望未来云开发可以提供 <strong><em>数据库长连接监控</em></strong> 的功能，这样通过订阅者模式可以很轻松地获取到数据更新的状态，主动提醒也就更容易实现了。到那时我可能会再更新相关源码。</p>\n<h4>6.6 关于云函数耗时</h4>\n<p>读者可能会发现我有一个叫 <code>benchmark</code> 的云函数，这个函数只是做了个查询数据库的操作，目的在于计算查询耗时。</p>\n<p>诡异的是，我前天在调试的时候，发现查询一次需要1秒钟，而写这篇文章时却不到100ms。建议在一些需要多次操作数据库的函数配置里，把超时时间设置长一点吧。目前云函数的性能不太稳定。</p>\n<h3>7. 结语</h3>\n<p>那么关于迷你版微博开发实战介绍就到此为止了，更多资料可以直接下载源码查看哦。</p>\n<h1>源码链接</h1>\n<p><a href=\"https://github.com/TencentCloudBase/Good-practice-tutorial-recommended\">https://github.com/TencentCloudBase/Good-practice-tutorial-recommended</a></p>\n<p><img src=\"//static.cnodejs.org/Fl6cvNxYzm89pOVSALRl35RBZE6f#pic_center\" alt=\"WechatIMG76.png\"></p>\n<p>如果你有关于使用云开发CloudBase相关的技术故事/技术实战经验想要跟大家分享，欢迎留言联系我们哦~比心！</p>\n</div>",
      "title": "小程序·云开发实战 - 迷你微博",
      "last_reply_at": "2019-07-24T03:25:39.792Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 388,
      "create_at": "2019-07-24T03:25:39.792Z",
      "author": {
        "loginname": "TencentTCB",
        "avatar_url": "https://avatars0.githubusercontent.com/u/51230659?v=4&s=120"
      }
    },
    {
      "id": "5d36ff6effed731686461dbd",
      "author_id": "5d3410819969a529571d5ded",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>这是在论坛招聘里，我把所有要求对比总结出来的</p>\n<p>Express,KOA2\nES6,callback,promise, async/await 等异步控制方法,并知晓其原理Webscoket\nMysql,Nosql,Redis\n了解nodejs服务日常运维各环节,熟悉进程管理,日志管理的各种工具\n具有扎实的编程功底和建模能力，精通常用的数据结构、算法、设计模式；\nDevOps 自动化运维，熟练使用 Docker 及相关技术栈；\n了解公有云和私有云的区别，若有公有云的使用经验为更佳，例如 AWS、阿里云、腾讯云、Google Cloud 等（熟悉 AWS 者优先考虑）；</p>\n<p>本人刚毕业没多久，还没接触过职场，希望大佬们能指点下我\n作为一个新人，职场面试求职，nodejs后端，要准备什么，要准备到什么程度\n提前谢谢大佬们了</p>\n</div>",
      "title": "后端面试 需要学习什么？",
      "last_reply_at": "2019-07-24T01:51:06.927Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 606,
      "create_at": "2019-07-23T12:37:02.213Z",
      "author": {
        "loginname": "Josh119891",
        "avatar_url": "https://avatars0.githubusercontent.com/u/18020366?v=4&s=120"
      }
    },
    {
      "id": "5b630389b71aedfe4c1266a2",
      "author_id": "5b62fab258db3ccf66a4516b",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>近期在学习node.js，由于自己是初学者，看了《Node.js开发指南》和 《Node.js开发实战》上的一些基础的东西，《深入浅出 Node.js》看起来是很吃力，最近试着用Express开发自己的一个 个人博客系统，刚刚开始，就感觉很吃力，最近就在想该怎么来学习，希望曾经和我有相同问题的朋友解答下我的疑惑，学习路线很迷茫啊。。。</p>\n</div>",
      "title": "node.js的入门（萌新）",
      "last_reply_at": "2019-07-24T01:41:12.864Z",
      "good": false,
      "top": false,
      "reply_count": 46,
      "visit_count": 7359,
      "create_at": "2018-08-02T13:13:45.110Z",
      "author": {
        "loginname": "remembergf",
        "avatar_url": "https://avatars1.githubusercontent.com/u/34055216?v=4&s=120"
      }
    },
    {
      "id": "5c2190c176c4964062a1d641",
      "author_id": "58d140302c8bf2a836456213",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>摘要：</strong> 对JSer来说，这是很有意思的1年。</p>\n<p>本文灵感来自<a href=\"https://javascriptweekly.com/\">JavaScript Weekly</a>周报，欢迎大家订阅。</p>\n<h3>The State of JavaScript 2018</h3>\n<p><a href=\"https://2018.stateofjs.com/\">The State of JavaScript</a>调研已经连续做了3年(<a href=\"http://2016.stateofjs.com/\">2016</a>, <a href=\"https://2017.stateofjs.com/\">2017</a>, <a href=\"https://2018.stateofjs.com\">2018</a>)，<a href=\"https://2018.stateofjs.com/\">今年</a>一共调研了2万多个JS开发者。有这样一些有意思的发现：</p>\n<ul>\n<li>绝大多数开发者都用过ES6，同时TypeScript也越来越流行了；</li>\n<li>React依然最流行的前端框架，同时Vue也越来越受欢迎了；</li>\n<li>Express依然是最流行的Node.js框架(Node 8已经支持async函数了，Koa的价值应该少了很多)；</li>\n<li>Visual Studio code远远超越Sublime，成为最流行的JS编辑器；</li>\n</ul>\n<p>作为一个后端用Express框架，尽量使用最新的ECMAScript语法，而前端用着TypeScript，不过框架还是AngularJS 1(这事要怪版本帝Angular不向后兼容)，抛弃价值70刀的Sublime，今年加入VS code阵营的JSer，我也是算是够主流了吧！那你呢？</p>\n<h3>ECMAScript 2018</h3>\n<p>TC39(ECMAScript标准委员会)这些年越来越勤快了，从2015年(ES6)开始，每年发布一个新的ECMAScipt标准。今年大佬们继续忙于处理各种<a href=\"https://github.com/tc39/proposals\">proposal</a>。<a href=\"https://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript 2018</a>，即ES9，则在6月如期发布了，其新增的特性并不多：</p>\n<p><strong>主要新特性:</strong></p>\n<ul>\n<li><a href=\"http://2ality.com/2016/10/asynchronous-iteration.html\">Asynchronous Iteration</a></li>\n<li><a href=\"http://2ality.com/2016/10/rest-spread-properties.html\">Rest/Spread Properties</a></li>\n</ul>\n<p><strong>新的正则表达式特性</strong>:</p>\n<ul>\n<li><a href=\"http://2ality.com/2017/05/regexp-named-capture-groups.html\">RegExp named capture groups</a></li>\n<li><a href=\"http://2ality.com/2017/07/regexp-unicode-property-escapes.html\">RegExp Unicode Property Escapes</a></li>\n<li><a href=\"http://2ality.com/2017/05/regexp-lookbehind-assertions.html\">RegExp Lookbehind Assertions</a></li>\n<li><a href=\"http://2ality.com/2017/07/regexp-dotall-flag.html\"><code>s</code> (<code>dotAll</code>) flag for regular expressions</a></li>\n</ul>\n<p><strong>其他新特性</strong>:</p>\n<ul>\n<li><a href=\"http://2ality.com/2017/07/promise-prototype-finally.html\"><code>Promise.prototype.finally()</code></a></li>\n<li><a href=\"http://2ality.com/2016/09/template-literal-revision.html\">Template Literal Revision</a></li>\n</ul>\n<p>如果想了解ES9的细节，阔以看看<a href=\"http://dr-axel.de/\">Axel Rauschmayer</a>博士写的<a href=\"http://exploringjs.com/es2018-es2019/toc.html\">Exploring ES2018 and ES2019</a>。</p>\n<h3>Node 10</h3>\n<p>Node 10在4月<a href=\"https://nodejs.org/en/blog/release/v10.0.0/\">发布</a>并且在10月成为<a href=\"https://medium.com/@nodejs/october-brings-node-js-10-x-to-lts-and-node-js-11-to-current-ae19f8f12b51\">LTS</a>，即长期支持版本。</p>\n<p>Node 10使用了新的<a href=\"https://v8.dev/\">V8引擎</a>6.8，因此性能提升了很多，比如<a href=\"https://v8.dev/blog/fast-async\">Promise与Async函数的性能提升就非常明显</a>，因此建议大家升级。</p>\n<p>Node新版本的<a href=\"https://github.com/nodejs/release\">发布日期</a>一直非常稳定，做到这一点也是不容易啊！</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-node.png\" alt></p>\n<h3>Vue 3.0</h3>\n<p>在<a href=\"https://vuetoronto.com/\">Vue.js Conference Toronto 2018</a>上，尤雨溪发表了主题演讲<a href=\"https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/edit#slide=id.p\">Vue 3.0 Updates</a>，新版本将会有这些变化：</p>\n<ul>\n<li>更快</li>\n<li>更小</li>\n<li>更易于维护</li>\n<li>更多的原生支持</li>\n<li><a href=\"https://www.zhihu.com/question/46397274/answer/101193678\">放弃Flow，使用TypeScript</a></li>\n</ul>\n<p>Vue 3.0<a href=\"https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf\">预计将在2019发布</a>，大家期待吧！</p>\n<h3>Babel 7</h3>\n<p>2年多时间commit了4000多次，<a href=\"https://babeljs.io/blog/2018/08/27/7.0.0\">Babel 7终于发布了</a>，新增了下面这些特性：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/babel-upgrade\">babel-upgrade</a>: 升级Babel的工具；</li>\n<li><a href=\"https://babeljs.io/docs/en/next/config-files#project-wide-configuration\">babel.config.js</a>：学习ESLint与Webpack，使用JS文件配置；</li>\n<li><a href=\"https://babeljs.io/docs/en/options#overrides\">overrides</a>：允许同一个项目使用不同的Babel配置，例如前端代码的targets为Chrome 60，而后端代码的targets为Node 8；</li>\n<li>…</li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2018-12-24-babel.png\" alt></p>\n<p>主流浏览器对新的ECMAScript特性已经支持得不错了，不过还是存在并且永远存在很多非主流浏览器，于是我们还是离不开神奇的Babel。</p>\n<h3>jQuery 3.3.0</h3>\n<p>曾经风靡一时的<a href=\"http://blog.jquery.com/2018/01/19/jquery-3-3-0-a-fragrant-bouquet-of-deprecations-and-is-that-a-new-feature/\">jQuery发布了3.3.0</a>，这个版本放弃了(deprecated)一系列方法：</p>\n<ul>\n<li>jQuery.now</li>\n<li>jQuery.isWindow</li>\n<li>jQuery.camelCase</li>\n<li>jQuery.proxy</li>\n<li>jQuery.type</li>\n<li>jQuery.isNumeric</li>\n<li>jQuery.isFunction</li>\n<li>Event aliases</li>\n</ul>\n<p>这些方法大多会在jQuery 4.0中被删除，因此jQuery官方鼓励大家使用替代的方法。</p>\n<p>从这个更新也能看出端倪，jQuery时代已经逐渐过去了，<a href=\"https://githubengineering.com/removing-jquery-from-github-frontend/\">GitHub的极客们干脆完全抛弃了jQuery</a>。</p>\n<h3>V8引擎10周年</h3>\n<p>强大的<a href=\"https://v8.dev/blog/10-years\">V8引擎已经发布10周年了</a>，它的命名灵感来自超级性能车的V8引擎，果然名副其实！其性能一直稳步提高：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-v8.png\" alt></p>\n<p>V8引擎当初是为Chrome浏览器开发的，但是早已成为一个独立的项目。国内的众多浏览器，包括搜狗、360、猎豹、QQ、百度、UC都是基于<a href=\"https://zh.wikipedia.org/wiki/Chromium\">Chromium</a>浏览器开发，而Chromium相当于开源版本的Chrome，自然也是基于V8引擎的。因此，众多&quot;国产&quot;浏览器实际上都是基于V8的。融资了2.5亿元红芯浏览器也不例外，<a href=\"https://www.pingwest.com/a/176061\">他们干脆打包了Chrome浏览器的安装包</a>，果然有钱任性！还有，就连浏览器界的一朵奇葩<a href=\"https://www.ifanr.com/1138933\">Microsoft也投靠了Chromium阵营</a>。</p>\n<p>另外，Node.js也是基于V8引擎的。</p>\n<h3>NPM模块<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>被黑客攻击</h3>\n<p>这件事闹得沸沸扬扬，不过只是有很多噱头，如果<a href=\"https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/\">认真分析黑客干了什么</a>，其真实影响没那么大，至少Vue开发者没啥好担心的：</p>\n<ul>\n<li>比特币钱包<a href=\"https://github.com/bitpay/copay\">copay</a>依赖<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块；</li>\n<li>黑客从骗取了<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块的npm发布权限；</li>\n<li>黑客为<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块添加了依赖<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>；</li>\n<li><a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>含有黑客代码，仅会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行，窃取用户的密码、私钥等信息，从而盗取比特币；</li>\n<li>有人说什么Vue可能遭受攻击，其实没有这回事，因为黑客代码只会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行。只有<a href=\"https://github.com/bitpay/copay\">copay</a>项目的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json\">package.json</a>中的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json#L3\">description</a>字符串&quot;A Secure Bitcoin Wallet&quot;能够解密黑客代码；而且，黑客的代码是为<a href=\"https://github.com/bitpay/copay\">copay</a>量身定做的，对其他项目没有作用；再说，黑客是来窃取的比特币的，又不是挖矿，你的项目有比特币给人家偷吗?</li>\n</ul>\n<p>同学们，不要被标题党给骗了啊！</p>\n<h3>《Refactoring》第2版改用JavaScript</h3>\n<p><a href=\"https://book.douban.com/subject/1229923/\">《重构：改善既有代码的设计》</a>大多数人都没看过，但是至少应该都听过。这本书刚出了<a href=\"https://www.amazon.com/gp/product/0134757599\">第二版</a>，所有示例代码由Java改成了JavaScript。</p>\n<p>根据作者<a href=\"https://martinfowler.com/articles/refactoring-2nd-ed.html\">Martin Fowler</a>的<a href=\"https://martinfowler.com/articles/refactoring-2nd-ed.html\">解释</a>，**《重构》这本书重点在于思想，适用于各种编程语言，所以选择什么语言并不重要。**而他选择JavaScript的原因很简单，因为JS既支持面向过程编程，又支持面向对象编程，这样方便写非OOP代码重构的示例。</p>\n<p>这里不妨引用<a href=\"https://www.zhihu.com/question/46397274/answer/101193678\">尤雨溪</a>的一句话：</p>\n<blockquote>\n<p>至于重构、设计什么的，我只想说，看的是使用的人的水平，跟用什么语言没那么大关系。水平烂的人用 TS 一样写的是翔一样的代码，看看 java 就知道了。</p>\n</blockquote>\n<p>《Refactoring》的示例代码用什么语言写根本不重要，重要的是背后的编程思想。顺便推荐一下《Clean Code》。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-refactoring.jpg\" alt></p>\n<p>这本书原价54.66刀，的确有点贵，不过算是必读书，大家看着办…</p>\n<h3>GitHub抛弃jQuery</h3>\n<p>一直以来，GitHub最流行的编程语言都是JavaScript，可以说GitHub是全球最大的JS开发者社交平台了；同时，因为被IE的兼容问题折磨了多年，前端痛恨Microsoft！但是，有钱任性的Microsoft以75亿美元收购了GitHub！</p>\n<p>另外，<a href=\"https://githubengineering.com/removing-jquery-from-github-frontend/\">GitHub的技术极客们花了数年时间，以非常规范的流程完全移除GitHub网站了jQuery</a>：</p>\n<ul>\n<li>实现了一个ESlint插件<a href=\"https://github.com/dgraham/eslint-plugin-jquery\">eslint-plugin-jquery</a>，禁止在代码中使用已经弃用的jQuery方法。这样可以防止同事使用jQuery方法。</li>\n<li>使用原生代码重写了2个依赖于jQuery的模块<a href=\"https://github.com/defunkt/jquery-pjax\">jquery-pjax</a>和<a href=\"https://github.com/defunkt/facebox\">facebox</a>。</li>\n<li>开发一个定制的jQuery版本，一旦完全移除某个jQuery方法，就删除jQuery中的对应代码。这样既可以减少jQuery大小，也可以防止同事使用已经移除的jQuery方法。</li>\n<li>根据用户统计数据，来逐步放弃支持低版本的IE浏览器，这样的话可以无需依赖jQuery来保证兼容性。</li>\n<li>…</li>\n</ul>\n<p>是否使用jQuery各有各的想法和需求，但是<strong>GitHub弃用jQuery的流程非常专业，可以作为处理技术债的标准规范</strong>。</p>\n<h3>Microsoft爱上JavaScript</h3>\n<p>土豪Microsoft似乎爱上了JavaScript，它家的<a href=\"https://www.reddit.com/r/programming/comments/8qqhlz/comment/e0ll1dt/\">Office 365, MicroSoft Teams以及Skype都开始使用JavaScript重写了</a>。原因无疑是JS的跨平台特性。同一套代码多处运行，虽然现在还有很多问题，但是这样的未来不是挺好么？</p>\n<p>此处应该再来感受一下大名鼎鼎的<a href=\"https://blog.codinghorror.com/the-principle-of-least-power/\">Atwood’s Law</a>：</p>\n<blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript</p>\n</blockquote>\n<p>在浏览器市场上，Microsoft曾经通过捆绑Windows打败了网景，不过这些年在Chrome面前一败涂地，现在终于&quot;认输&quot;，选择<a href=\"https://www.ifanr.com/1138933\">基于Chromium重写浏览器</a>。对于JSer来说，至少意味着浏览器兼容问题可以缓解很多。</p>\n<p>根据<a href=\"https://2018.stateofjs.com/other-tools/\">The State of JavaScript 2018</a>，Microsoft开发的<a href=\"https://code.visualstudio.com/\">Visual Studio code</a>俨然已经成为最受JSer欢迎的代码编辑器，一些流行插件下载量高达上千万：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-vscode.png\" alt></p>\n<p>市值超过Apple，重回全球市值最高公司的Microsoft有钱任性，买下了JS开发者最多的GitHub。</p>\n<p>IT界的罗马帝国(出处：吴军《浪潮之巅》)Microsoft又重新崛起了，这是一件很了不起的事情。</p>\n<h3>Oracle宣示JavaScript主权</h3>\n<p><a href=\"https://mp.weixin.qq.com/s/gRtOaTXdLYVrIPnejVytMw\">Oracle明年就要开始给Java收费</a>，虽然只是JDK 8的u192之后的更新要收费，这个行为大概会让很多Java开发者不爽…</p>\n<p>另外，<a href=\"https://mp.weixin.qq.com/s/Q5bK8qHgLRzTsrA3NdC9wQ?\">Oracle还要求一个iOS开发者将一款叫做”HTML5, CSS, JavaScript, HTML, Snippet Editor“的App从App Store下架</a>，因为App名字中包含“JavaScript”字眼，而Oracle拥有JavaScript在美国的商标权。</p>\n<p>Oracle这位大爷惹不起，因此大家正在一本正经地<a href=\"https://www.techrepublic.com/article/why-its-finally-time-to-give-up-on-the-name-javascript/\">建议给JavaScript改名</a>。当然这基本上是不可能的，这辈子都不可能。。。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/\">JavaScript黑客是这样窃取比特币的，Vue开发者不用担心！</a></li>\n<li><a href=\"https://blog.fundebug.com/2018/11/28/10-english-technolody-newsletter/\">强烈推荐10个值得订阅的国外技术周报</a></li>\n<li><a href=\"https://blog.fundebug.com/2018/08/10/ecmascript-2018/\">ECMAScript 2018特性确定了</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，得到了Google、360、金山软件、百姓网等众多知名用户的认可。欢迎免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2018/12/25/what-happens-in-2018-for-javascript/\">https://blog.fundebug.com/2018/12/25/what-happens-in-2018-for-javascript/</a></p>\n</div>",
      "title": "2018年，JavaScript都经历了什么？",
      "last_reply_at": "2019-07-24T01:29:50.691Z",
      "good": true,
      "top": false,
      "reply_count": 16,
      "visit_count": 4821,
      "create_at": "2018-12-25T02:06:57.767Z",
      "author": {
        "loginname": "Fundebug",
        "avatar_url": "https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"
      }
    }
  ]
}